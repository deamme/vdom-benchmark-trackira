{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","web/js/main.js","node_modules/trackira/dist/trackira.js","node_modules/vdom-benchmark-base/lib/benchmark.js","node_modules/vdom-benchmark-base/lib/executor.js","node_modules/vdom-benchmark-base/lib/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/4DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar benchmark = require('vdom-benchmark-base');\nvar t = require('trackira');\n\nvar NAME = 'Trackira';\nvar VERSION = t.version;\n\nfunction renderTree(nodes) {\n  var children = [];\n  var i;\n  var e;\n  var n;\n\n  for (i = 0; i < nodes.length; i++) {\n    n = nodes[i];\n    if (n.children !== null) {\n      children.push(new t.Element('div', {key: n.key}, renderTree(n.children)));\n    } else {\n      children.push(new t.Element('span', {key: n.key}, [new t.Text(n.key.toString())]));\n    }\n  }\n\n  return children;\n}\n\nfunction BenchmarkImpl(container, a, b) {\n  this.container = container;\n  this.a = a;\n  this.b = b;\n  this._node = null;\n}\n\nBenchmarkImpl.prototype.setUp = function() {\n};\n\nBenchmarkImpl.prototype.tearDown = function() {\n  t.detach(this.container);\n};\n\nBenchmarkImpl.prototype.render = function() {\n  this._node = new t.Element('div', null, renderTree(this.a));\n  this._node.render(this.container);\n};\n\nBenchmarkImpl.prototype.update = function() {\n  var newNode = new t.Element('div', {}, renderTree(this.b));\n  this._node = t.patch(this._node, newNode);\n};\n\ndocument.addEventListener('DOMContentLoaded', function(e) {\n  benchmark(NAME, VERSION, BenchmarkImpl);\n}, false);","/**\n * trackira - Virtual DOM boilerplate\n * @Version: v0.1.1a\n * @Author: Kenny Flashlight\n * @Homepage: http://trackira.github.io/trackira/\n * @License: MIT\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Trackira = factory();\n})(this, function () {\n    'use strict';\n\n    var TEXT = 1;\n    var ELEMENT = 2;\n    var COMMENT = 3;\n\n    var ESCAPE_LOOKUP = {\n        '&': '&amp;',\n        '>': '&gt;',\n        '<': '&lt;',\n        '\"': '&quot;',\n        '\\'': '&#x27;'\n    },\n        ESCAPE_REGEX = /[&><\"']/g,\n        escaper = function escaper(match) {\n        return ESCAPE_LOOKUP[match];\n    };\n\n    /**\n     * Escapes text to prevent scripting attacks.\n     *\n     * @param {*} text Text value to escape.\n     * @return {string} An escaped string.\n     */\n    var escapeHtml = function escapeHtml(text) {\n        return ('' + text).replace(ESCAPE_REGEX, escaper);\n    };\n\n    function Text(text) {\n        this.text = '' + text;\n    }\n\n    Text.prototype = {\n\n        type: TEXT,\n\n        /**\n         * Render and return a virtual text node\n         *\n         * @return Object\n         */\n        render: function render() {\n            if (!this.node) {\n                this.node = document.createTextNode(this.text);\n            }\n            return this.node;\n        },\n\n        /**\n         * Attaches an existing textual DOM element.\n         *\n         * @param  {Object} node\n         * @return {Object}\n         */\n        attach: function attach(node) {\n            return this.node = node;\n        },\n\n        /**\n         * Patches the node by updating the nodeValue.\n         *\n         * @param {object} to Contains the next text content.\n         * @return {Object}\n         */\n        patch: function patch(to) {\n\n            if (this.equalTo(to)) {\n\n                // .nodeValue gives better performance then textContent\n                // http://jsperf.com/update-textcontent-vs-data-vs-nodevalue\n                if (to.text !== this.text) {\n                    this.node.nodeValue = to.text;\n                }\n\n                return to.node = this.node;\n            }\n\n            // If not the same, destroy the node\n            this.destroy();\n            // ... and re-render\n            to.render();\n        },\n\n        /**\n         * Removes the DOM node attached to the virtual node.\n         */\n        detach: function detach() {\n            this.destroy();\n        },\n\n        /**\n         * Creates an html markup of the text node. This node is not intended to have\n         * any features besides containing text content.\n         */\n        toHTML: function toHTML() {\n            return escapeHtml(this.text);\n        },\n\n        /**\n         * Destroys the text node attached to the virtual node.\n         */\n        destroy: function destroy() {\n            var node = this.node;\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        },\n\n        /**\n         * Checks if two virtual text nodes are equal to each other, and they can be updated.\n         *\n         * @param {Object} to\n         * @return {boolean}\n         */\n        equalTo: function equalTo(node) {\n            return this.type === node.type;\n        }\n    };\n\n    function Comment(comment) {\n\n        this.comment = '' + comment;\n    }\n\n    Comment.prototype = {\n\n        type: COMMENT,\n\n        /**\n         * Render and return a virtual comment node\n         *\n         * @return Object\n         */\n        render: function render() {\n            if (!this.node) {\n                this.node = document.createComment(this.comment);\n                return this.node;\n            }\n        },\n        /**\n         * Patches the node by updating the nodeValue.\n         *\n         * @param {object} to Contains the next text content.\n         * @return {Object}\n         */\n        patch: function patch(to) {\n\n            if (this.equalTo(to)) {\n\n                // .nodeValue gives better performance then textContent\n                // http://jsperf.com/update-textcontent-vs-data-vs-nodevalue\n                if (to.comment !== this.comment) {\n                    this.node.nodeValue = to.comment;\n                }\n                return to.node = this.node;\n            }\n\n            // If not the same, destroy the node\n            this.destroy();\n            // ... and re-render\n            to.render();\n        },\n\n        /**\n         * Attaches an existing textual DOM element.\n         *\n         * @param  {Object} node\n         * @return {Object}\n         */\n        attach: function attach(node) {\n            return this.node = node;\n        },\n\n        /**\n         * Returns an html representation of the comment node.\n         */\n        toHTML: function toHTML() {\n            return '<!-- ' + this.comment.replace(/^\\s+|\\s+$/gm, '') + ' -->';\n        },\n\n        /**\n         * Destroys the text node attached to the virtual node.\n         */\n        destroy: function destroy() {\n\n            var node = this.node;\n\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        },\n\n        /**\n         * Removes the DOM node attached to the virtual node.\n         */\n        detach: function detach() {\n\n            this.destroy();\n        },\n\n        /**\n         * Checks if two virtual comment nodes are equal to each other, and if they can be updated.\n         *\n         * @param {Object} to\n         * @return {boolean}\n         */\n        equalTo: function equalTo(to) {\n            return this.type === to.type;\n        }\n    };\n\n    /** Export */\n\n    var attach = function attach(root, nodes, parent) {\n\n        if (typeof nodes === 'function') {\n            nodes = nodes(root, parent);\n        }\n\n        if (!(nodes instanceof Array)) {\n            nodes = [nodes];\n        }\n\n        var i = 0,\n            j = 0,\n            childNodes = root.childNodes,\n            nodesLen = nodes.length,\n            text,\n            textLen,\n            size;\n\n        while (i < nodesLen) {\n\n            if (!nodes[i]) {\n                i++;\n                continue;\n            }\n\n            if (nodes[i].type === COMMENT) {\n                // comment node\n\n                size = nodes[i].comment.length;\n                text = childNodes[j].data;\n\n                nodes[i].comment = text;\n                nodes[i].attach(childNodes[j], parent);\n                i++;\n\n                textLen = text.length;\n\n                while (size < textLen && i < nodesLen) {\n                    size += nodes[i].comment.length;\n                    nodes[i].comment = '';\n                    i++;\n                }\n            } else if (nodes[i].type === TEXT) {\n                // text node\n\n                size = nodes[i].text.length;\n                text = childNodes[j].data;\n\n                nodes[i].text = text;\n                nodes[i].attach(childNodes[j], parent);\n                i++;\n\n                textLen = text.length;\n\n                while (size < textLen && i < nodesLen) {\n                    size += nodes[i].text.length;\n                    nodes[i].text = '';\n                    i++;\n                }\n            } else {\n                nodes[i].attach(childNodes[j], parent);\n                i++;\n            }\n            j++;\n        }\n        return nodes;\n    };\n\n    /**\r\n      * Combines multiple className strings into one.\r\n      *\r\n      * @param {String|Number|Object} className\r\n      * @return {string}\r\n      */\n    var processClasses = function processClasses(className) {\n\n        if (typeof className === 'string' || typeof className === 'number') {\n            return className;\n        }\n\n        if (typeof className === 'object') {\n\n            var key,\n                classes = '';\n\n            for (key in className) {\n\n                if (className[key]) {\n                    classes += ' ' + key;\n                }\n            }\n            // https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/88\n            return classes.substr(1);\n        }\n    };\n\n    var renderProperties = function renderProperties(node, props) {\n\n        var propKey, propValue;\n\n        for (propKey in props) {\n            propValue = props[propKey];\n            if (propKey === 'className' && propValue !== undefined) {\n                node.className = processClasses(propValue);\n            } else if (propValue !== undefined) {\n                node[propKey] = propValue;\n            }\n        }\n    };\n\n    var prototype_attach = function prototype_attach(node, parent) {\n\n        this.parent = parent;\n        this.node = node;\n\n        if (this.events) {\n            node.__root__ = this;\n        }\n\n        // Render properties\n        renderProperties(this.node, this.props);\n\n        // Render children   \n        if (this.children) {\n            attach(node, this.children, this);\n        }\n        // Handle callbacks\n        if (this.callbacks && this.callbacks.created) {\n            this.callbacks.created(this, node);\n        }\n\n        return node;\n    };\n\n    /**\n     * Create root level element of the virtual node.\n     *\n     * @return {Object}\n     */\n    var create = function create() {\n\n        if (this.namespace) {\n            return this.is ? document.createElementNS(this.namespace, this.tagName, this.is) : document.createElementNS(this.namespace, this.tagName);\n        }\n        // custom element/web component support\n        return this.is ? document.createElement(this.tagName, this.is) : document.createElement(this.tagName);\n    };\n\n    // For HTML, certain tags should omit their close tag. We keep a whitelist for\n    // those special cased tags\n\n    var voidElementNames = {\n        'area': true,\n        'base': true,\n        'br': true,\n        'col': true,\n        'command': true,\n        'embed': true,\n        'hr': true,\n        'img': true,\n        'input': true,\n        'keygen': true,\n        'link': true,\n        //    \"menuitem\": true,\n        'meta': true,\n        'param': true,\n        'source': true,\n        'track': true,\n        'wbr': true\n        // NOTE: menuitem's close tag should be omitted, but that causes problems.\n    };\n\n    /**\n     *  Creates markup for HTML class / className attribute / properties\n     *\n     * @param {Object} value\n     * @return {String}\n     * @example\n     *\n     * new Trackira.Element(\"div\", attrs: { class: { \"foo\":true, \"bar\":false, \"baz\":true } }).toHTML();\n     *\n     * Result:  <div class=\"foo baz\"></div>   // \"bar\" are skipped because it's a falsy value\n     */\n    var createMarkupForClass = function createMarkupForClass(value) {\n\n        if (typeof value === 'string') {\n            return value;\n        }\n\n        var key,\n            markup = '';\n\n        for (key in value) {\n            // the value will only be stringified if the value itself is true\n            if (value[key]) {\n                markup += key + ' ';\n            }\n        }\n        return markup.trim();\n    };\n\n    /**\r\n     *  Creates markup for CSS style values\r\n     *\r\n     * @param {Object} styles\r\n     * @return {String}\r\n     */\n    var createMarkupForStyles = function createMarkupForStyles(styles) {\n        if (typeof styles === 'object') {\n            var styleName,\n                styleValue,\n                serialized = '';\n            for (styleName in styles) {\n                if (styles[styleName]) {\n                    styleValue = styles[styleName];\n                    if (styleValue !== undefined) {\n                        serialized += styleName + ':';\n                        serialized += typeof styleValue === 'number' ? styleValue + 'px' : styleValue;\n                        serialized += ';';\n                    }\n                }\n            }\n            return serialized;\n        }\n        return styles;\n    };\n\n    var createMarkupForAttributes = function createMarkupForAttributes(attrs, tagName) {\n\n        var markup = '',\n            attrKey,\n            attrValue;\n\n        for (attrKey in attrs) {\n\n            if (attrKey !== 'innerHTML') {\n\n                attrValue = attrs[attrKey];\n\n                if (attrValue) {\n\n                    // Special case: \"style\"\n                    if (attrKey === 'style') {\n                        attrValue = createMarkupForStyles(attrValue);\n                    }\n                    // Special case: \"class\"\n                    if (attrKey === 'class') {\n                        attrValue = createMarkupForClass(attrValue);\n                    }\n\n                    // Special case - select and textarea values (should not be stringified)\n                    //              - contenteditable should be ignored\n                    if (!(attrKey === 'value' && (tagName === 'textarea' || tagName === 'select' || attrs.contenteditable))) {\n                        markup += ' ' + attrKey + '=\"' + '' + attrValue + '\"';\n                    }\n                }\n            }\n        }\n\n        return markup;\n    };\n\n    var whitelist = {\n        /**\r\n         * Standard Properties\r\n         */\n        accept: true,\n        acceptCharset: true,\n        accessKey: true,\n        action: true,\n        allowFullScreen: 1,\n        allowTransparency: true,\n        alt: true,\n        async: 1,\n        autocomplete: true,\n        autofocus: 1,\n        autoplay: 1,\n        capture: 1,\n        cellPadding: true,\n        cellSpacing: true,\n        charset: true,\n        challenge: true,\n        checked: 1,\n        classID: true,\n        className: true,\n        cols: true,\n        colSpan: true,\n        content: true,\n        contentEditable: true,\n        contextMenu: true,\n        controls: 1,\n        coords: true,\n        crossOrigin: true,\n        currentTime: true,\n        data: true,\n        dateTime: true,\n        defer: 1,\n        dir: true,\n        disabled: 1,\n        download: 2,\n        draggable: true,\n        enctype: true,\n        form: true,\n        formAction: true,\n        formEncType: true,\n        formMethod: true,\n        formNoValidate: 1,\n        formTarget: true,\n        frameBorder: true,\n        headers: true,\n        height: true,\n        hidden: 1,\n        href: true,\n        hreflang: true,\n        htmlFor: true,\n        httpEquiv: true,\n        icon: true,\n        id: true,\n        is: true,\n        keyParams: true,\n        keyType: true,\n        label: true,\n        lang: true,\n        list: true,\n        loop: 1,\n        low: true,\n        manifest: true,\n        marginHeight: true,\n        marginWidth: true,\n        max: true,\n        maxLength: true,\n        media: true,\n        mediaGroup: true,\n        method: true,\n        min: true,\n        minLength: true,\n        multiple: 1,\n        muted: 1,\n        name: true,\n        noValidate: 1,\n        open: true,\n        optimum: true,\n        pattern: true,\n        placeholder: true,\n        playbackRate: true,\n        poster: true,\n        preload: true,\n        radiogroup: true,\n        readOnly: 1,\n        rel: true,\n        required: 1,\n        role: true,\n        rows: true,\n        rowSpan: true,\n        sandbox: true,\n        scope: true,\n        scoped: 1,\n        scrolling: true,\n        seamless: 1,\n        selected: 1,\n        shape: true,\n        size: true,\n        sizes: true,\n        span: true,\n        spellcheck: true,\n        src: true,\n        srcdoc: true,\n        srcset: true,\n        srcObject: true,\n        start: true,\n        step: true,\n        style: true,\n        tabIndex: true,\n        target: true,\n        title: true,\n        type: true,\n        useMap: true,\n        value: true,\n        volume: true,\n        width: true,\n        wmode: true,\n\n        /**\r\n         * Non-standard Properties\r\n         */\n        // autoCapitalize and autoCorrect are supported in Mobile Safari for\n        // keyboard hints.\n        autocapitalize: true,\n        autocorrect: true,\n        // itemProp, itemScope, itemType are for Microdata support. See\n        // http://schema.org/docs/gs.html\n        itemProp: true,\n        itemScope: 1,\n        itemType: true,\n        // itemID and itemRef are for Microdata support as well but\n        // only specified in the the WHATWG spec document. See\n        // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api\n        itemID: true,\n        itemRef: true,\n        // property is supported for OpenGraph in meta tags.\n        property: true,\n        // IE-only attribute that controls focus behavior\n        unselectable: true\n    };\n\n    var attributeNames = {\n        acceptCharset: 'accept-charset',\n        className: 'class',\n        htmlFor: 'for',\n        httpEquiv: 'http-equiv'\n    };\n\n    var createAttribute = function createAttribute(key, value) {\n\n        key = (attributeNames[key] || key).toLowerCase();\n\n        var attrType = whitelist[key];\n\n        // a boolean `value` has to be truthy\n        // and a overloaded boolean `value` has to be === true\n        if (attrType === 1 || attrType === 2 && value === true) {\n            return escapeHtml(key);\n        }\n        return key + '=\"' + '' + value + '\"';\n    };\n\n    var createMarkupForProperties = function createMarkupForProperties(props) {\n        var markup = '',\n            attr,\n            propValue,\n            propKey;\n\n        for (propKey in props) {\n\n            if (propKey !== 'innerHTML') {\n\n                propValue = props[propKey];\n\n                if (propValue) {\n\n                    // Special case: \"style\"\n                    if (propKey === 'style') {\n                        propValue = createMarkupForStyles(propValue);\n                    }\n\n                    // Special case: \"class\"\n                    if (propKey === 'className') {\n                        propValue = createMarkupForClass(propValue);\n                    }\n\n                    attr = createAttribute(propKey, propValue);\n\n                    if (attr) {\n                        markup += ' ' + attr;\n                    }\n                }\n            }\n        }\n        return markup;\n    };\n\n    var toHTML = function toHTML() {\n\n        var node = this,\n            tagName = node.tagName.toLowerCase(),\n            html = '<' + tagName;\n\n        // stringify attributes\n        if (node.attrs) {\n            html += createMarkupForAttributes(node.attrs, node.tagName);\n        }\n\n        // stringify properties\n        if (node.props) {\n            html += createMarkupForProperties(node.props);\n        }\n\n        html = html + '>';\n\n        // stringify children\n        if (node.children.length) {\n            if (node.children.length === 1) {\n                html += node.children[0].toHTML();\n            } else {\n                var i = 0,\n                    len = node.children.length;\n                for (; i < len; i++) {\n                    html += node.children[i].toHTML();\n                }\n            }\n\n            // process innerHTML\n        } else if (node.props && node.props.innerHTML) {\n            html += node.props.innerHTML;\n        }\n\n        // add a closing tag if this isn't a void element\n        return html += voidElementNames[tagName] ? '' : '</' + tagName + '>';\n    };\n\n    /**\r\n     * Get namespace\r\n     *\r\n     * @param  {String} tagName\r\n     * @param  {Object} parentNode\r\n     * @return {String}\r\n     */\n    var getNamespace = function getNamespace(tagName, parentNode) {\n\n        // Use SVG namespace, if this is an <svg> element\n        if (tagName === 'svg') {\n            return 'http://www.w3.org/2000/svg';\n        }\n\n        // ...or MATH namespace, if this is an <math> element\n        if (tagName === 'math') {\n            return 'http://www.w3.org/1998/Math/MathML';\n        }\n\n        // ...or inherit from the parent node\n        if (parentNode) {\n            return parentNode.namespace;\n        }\n    };\n\n    var determineNameAndNamespace = function determineNameAndNamespace(value) {\n\n        var colonIndex, namespacePrefix, namespace;\n\n        // are we dealing with a namespaced attribute, e.g. xlink:href?\n        colonIndex = value.indexOf(':');\n\n        if (colonIndex !== -1) {\n\n            // looks like we are, yes...\n            namespacePrefix = value.substr(0, colonIndex);\n\n            value = value.substring(colonIndex + 1);\n\n            switch (namespacePrefix) {\n\n                case 'xlink':\n                    namespace = 'http://www.w3.org/1999/xlink';\n                    break;\n                case 'xml':\n                    namespace = 'http://www.w3.org/XML/1998/namespace';\n                    break;\n            }\n\n            return {\n                name: value,\n                namespace: namespace,\n                namespacePrefix: namespacePrefix\n            };\n        }\n    };\n\n    /**\n     * Invokes the `callback` function once for each item in `arr` collection,\n     * which can only be an array.\n     *\n     * @param {Array} collection\n     * @param {Function} callback\n     * @return {Array}\n     * @private\n     */\n    var each = function each(collection, callback) {\n        var arr = collection || [],\n            index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            callback(arr[index], index, arr);\n        }\n        return arr;\n    };\n\n    var // xlink namespace attributes\n    xlinkAttributes = 'xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type'.split(' '),\n\n    // xml namespace attributes\n    xmlAttributes = 'xml:base xml:id xml:lang xml:space'.split(' '),\n\n    // boolean attributes\n    bools = 'multiple,selected,checked,disabled,readOnly,required,open'.split(','),\n        hook = { set: {}, unset: {} };\n\n    // setter & getter for 'xlink' namespace attributes\n    each(xlinkAttributes, function (key) {\n\n        hook.set[key] = function (name, node, attrs, previous) {\n            if (attrs[name] || previous && previous[name] !== attrs[name]) {\n                var namespace = determineNameAndNamespace(name);\n                node.setAttributeNS(namespace.namespace, namespace.name, attrs[name]);\n            }\n        };\n\n        hook.unset[key] = function (name, node, previous) {\n            var namespace = determineNameAndNamespace(key);\n            node.removeAttributeNS(namespace.namespace, namespace.name);\n        };\n    });\n\n    // setter & getter for 'xml' namespace attributes\n    each(xmlAttributes, function (key) {\n\n        hook.set[key] = function (name, node, attrs, previous) {\n            if (attrs[name] || previous && previous[name] !== attrs[name]) {\n                var namespace = determineNameAndNamespace(key);\n                node.setAttributeNS(namespace.namespace, namespace.name, attrs[name]);\n            }\n        };\n\n        hook.unset[key] = function (name, node, previous) {\n            // Namespace attributes\n            var namespace = determineNameAndNamespace(key);\n            node.removeAttributeNS(namespace.namespace, namespace.name);\n        };\n    });\n\n    //# BOOLEAN ATTRIBUTES\n\n    each(bools, function (key) {\n        hook.set[key] = function (name, node, attrs, previous) {\n            if (attrs[name] || previous && previous[name] !== attrs[name]) {\n                // Only set boolean attributes if the value is not negative\n                if (attrs[name]) {\n                    node.setAttribute(key, attrs[name]);\n                    node[key] = true;\n                }\n            }\n        };\n    });\n    var specialAttrs = hook;\n\n    var renderAttributes = function renderAttributes(node, attrs) {\n\n        var attrName, attributeValue, attrValue, styleName;\n\n        for (attrName in attrs) {\n            attrValue = attrs[attrName];\n            if (attrValue !== undefined) {\n\n                if (attrName === 'style') {\n\n                    if (typeof attrValue === 'object') {\n                        for (styleName in attrValue) {\n                            attributeValue = attrValue[styleName];\n                            if (attributeValue) {\n                                node.style[styleName] = '' + attributeValue;\n                            }\n                        }\n                    } else if (typeof attrValue === 'string') {\n                        node.style.cssText = attrValue;\n                    }\n                } else if (attrName === 'value') {\n                    if (attrValue != null) {\n                        node.setAttribute(attrName, attrValue);\n                        node.value = attrValue;\n                    }\n                } else if (attrName === 'class') {\n                    node.setAttribute(attrName, processClasses(attrValue));\n                } else if (specialAttrs.set[attrName]) {\n                    specialAttrs.set[attrName](attrName, node, attrs, {});\n                } else {\n\n                    node.setAttribute(attrName, attrValue);\n                }\n            }\n        }\n    };\n\n    var processOption = function processOption(vnode, values) {\n\n        if (vnode.tagName === 'option') {\n\n            if (values[vnode.attrs && vnode.attrs.value]) {\n                vnode.attrs = vnode.attrs || {};\n                vnode.attrs.selected = 'selected';\n            } else if (values[vnode.props && vnode.props.value]) {\n                vnode.props = vnode.props || {};\n                vnode.props.selected = true;\n            }\n        } else {\n\n            // stringify children\n            if (vnode.children.length) {\n                if (vnode.children.length === 1) {\n                    processOption(vnode.children[0], values);\n                } else {\n                    var i = 0,\n                        len = vnode.children.length;\n                    for (; i < len; i++) {\n                        processOption(vnode.children[i], values);\n                    }\n                }\n            }\n        }\n    };\n\n    var renderSelect = function renderSelect(node) {\n\n        var selectValue = node.attrs && node.attrs.value || node.props && node.props.value,\n            values = {};\n\n        // If the <select> has a specified value, that should override\n        // these options\n        if (selectValue !== undefined) {\n            if (selectValue instanceof Array) {\n\n                var i = 0,\n                    value;\n\n                while (i < selectValue.length) {\n                    value = selectValue[i++];\n                    values[value] = value;\n                }\n            } else {\n                values[selectValue] = selectValue;\n            }\n\n            processOption(node, values);\n        }\n    };\n\n    var render = function render(parent) {\n\n        if (parent) {\n            this.parent = parent;\n        }\n\n        // Set valid namespace\n        if (this.namespace == null) {\n            this.namespace = getNamespace(this.tagName, parent) || null;\n        }\n\n        // create a new virtual element\n        var node = this.node = this.create(),\n            children = this.children;\n\n        // Special case - select\n        if (this.tagName === 'select') {\n            renderSelect(this);\n        }\n\n        // Render properties\n        renderProperties(this.node, this.props);\n\n        // Render attributes\n        renderAttributes(this.node, this.attrs);\n\n        // Render children\n        if (this.children.length) {\n            // ignore incompatible children\n            if (this.children.length === 1 && children[0]) {\n                this.node.appendChild(children[0].render(this));\n            } else {\n                var i = 0,\n                    len = children.length;\n                for (; i < len; i++) {\n                    if (children[i]) {\n                        this.node.appendChild(children[i].render(this));\n                    }\n                }\n            }\n        }\n        // only attach the vnode reference for DOM element which has defined events to minimize overhead\n        if (this.events) {\n            node.__root__ = this;\n        }\n\n        // Handle callbacks\n        if (this.callbacks && this.callbacks.created) {\n            this.callbacks.created(this, node);\n        }\n\n        return node;\n    };\n\n    /**\n     * Remove a real DOM element from where it was inserted\n     */\n    var prototype_destroy = function prototype_destroy() {\n\n        var node = this.node,\n            parentElement;\n\n        if (node) {\n\n            // need to check for parent node - DOM may have been altered\n            // by something other than Trackira! e.g. jQuery UI...\n            if (parentElement = node.parentElement) {\n\n                if (!this.callbacks || !this.callbacks.destroy) {\n                    return parentElement.removeChild(node);\n                }\n\n                this.callbacks.destroy(node, function () {\n                    parentElement.removeChild(node);\n                });\n            }\n            // should silently abort if the element has no parent\n        }\n    };\n\n    /**\r\n     * @module detach\r\n     */\n    var detach = function detach(nodes) {\n        var i = 0;\n\n        while (i < nodes.length) {\n            nodes[i++].detach();\n        }\n    };\n\n    /**\r\n     * Inserts `childNode` as a child of `parentNode` at the `index`.\r\n     *\r\n     * @param {DOMElement} parentNode Parent node in which to insert.\r\n     * @param {DOMElement} childNode Child node to insert.\r\n     * @param {number} index Index at which to insert the child.\r\n     * @internal\r\n     */\n    var insertChildAt = function insertChildAt(parentNode, childNode, nextChild) {\n        // By exploiting arrays returning `undefined` for an undefined index, we can\n        // rely exclusively on `insertBefore(node, null)` instead of also using\n        // `appendChild(node)`. However, using `undefined` is not allowed by all\n        // browsers so we must replace it with `null`.\n        parentNode.insertBefore(childNode, nextChild ? nextChild.node : null);\n    };\n\n    var updateChildren = function updateChildren(parentNode, oldChildren, newChildren) {\n\n        var oldStartIndex = 0,\n            oldStartNode = oldChildren[0],\n            newStartNode = newChildren[0];\n\n        if (oldChildren != null && oldChildren.length > 0) {\n            // Detach all 'oldChildren' if there is no 'newChildren'\n            if (newChildren.length === 0) {\n                detach(oldChildren);\n            } else if (oldChildren.length === 1 && newChildren.length === 1) {\n\n                if (oldStartNode.equalTo(newStartNode)) {\n                    oldStartNode.patch(newStartNode);\n                } else {\n                    insertChildAt(parentNode, newStartNode.render(), oldStartNode);\n                    oldChildren[0].detach();\n                }\n            } else {\n\n                var startIndex = 0,\n                    indexes,\n                    index,\n                    node,\n                    newEndIndex = newChildren.length - 1,\n                    oldEndIndex = oldChildren.length - 1,\n                    newEndNode = newChildren[newEndIndex],\n                    oldEndNode = oldChildren[oldEndIndex];\n\n                while (oldStartIndex <= oldEndIndex && startIndex <= newEndIndex) {\n                    if (oldStartNode === undefined) {\n                        oldStartIndex++; // node has been moved left\n                    } else if (oldEndNode === undefined) {\n                        oldEndIndex--;\n                    } else if (oldStartNode.equalTo(newStartNode)) {\n                        oldStartNode.patch(newStartNode);\n                        oldStartIndex++;\n                        startIndex++;\n                    } else if (oldEndNode.equalTo(newEndNode)) {\n                        oldEndNode.patch(newEndNode);\n                        oldEndIndex--;\n                        newEndIndex--;\n                    } else if (oldStartNode.equalTo(newEndNode)) {\n                        // node has moved right\n\n                        oldStartNode.patch(newEndNode);\n\n                        /**\r\n                         * If 'nextElementSibling' is undefined, the child will be inserted after nothing,\r\n                         * which is the same as inserting it at the beginning. For this approach, 'appendChild'\r\n                         * gives better performance.\r\n                         */\n\n                        if (oldEndNode.node.nextElementSibling) {\n                            parentNode.insertBefore(oldStartNode.node, oldEndNode.node.nextElementSibling);\n                        } else {\n                            parentNode.appendChild(oldStartNode.node);\n                        }\n\n                        oldStartIndex++;\n                        newEndIndex--;\n                    } else if (oldEndNode.equalTo(newStartNode)) {\n                        oldEndNode.patch(newStartNode);\n                        insertChildAt(parentNode, oldEndNode.node, oldStartNode);\n                        oldEndIndex--;\n                        startIndex++;\n                    } else {\n\n                        if (indexes === undefined) {\n\n                            indexes = {};\n\n                            for (index = oldEndIndex; index >= oldStartIndex; index--) {\n                                indexes[oldChildren[index].key] = index;\n                            }\n                        }\n\n                        index = indexes[newStartNode.key];\n\n                        if (index === undefined) {\n                            // New element\n                            insertChildAt(parentNode, newStartNode.render(), oldStartNode);\n                            startIndex++;\n                        } else {\n                            node = oldChildren[index];\n                            node.patch(newStartNode);\n                            oldChildren[index] = undefined;\n                            insertChildAt(parentNode, node.node, oldStartNode);\n                            startIndex++;\n                        }\n                    }\n\n                    oldEndNode = oldChildren[oldEndIndex];\n                    oldStartNode = oldChildren[oldStartIndex];\n                    newStartNode = newChildren[startIndex];\n                    newEndNode = newChildren[newEndIndex];\n                }\n\n                if (oldStartIndex > oldEndIndex) {\n\n                    while (startIndex <= newEndIndex) {\n                        insertChildAt(parentNode, newChildren[startIndex++].render(), newChildren[newEndIndex + 1]);\n                    }\n                } else if (startIndex > newEndIndex) {\n\n                    while (oldStartIndex <= oldEndIndex) {\n\n                        index = oldStartIndex++;\n\n                        if (oldChildren[index] !== undefined) {\n                            oldChildren[index].detach();\n                        }\n                    }\n                }\n            }\n\n            return newChildren;\n        }\n    };\n\n    var patchProperties = function patchProperties(node, properties, previousProperties) {\n\n        var propKey;\n\n        if (previousProperties) {\n            for (propKey in previousProperties) {\n                if (previousProperties[propKey] !== undefined && properties[propKey] === undefined) {\n                    if (propKey === 'className') {\n                        node.className = '';\n                    } else {\n                        node[propKey] = null;\n                    }\n                }\n            }\n        }\n        if (properties) {\n            for (propKey in properties) {\n                if (propKey === 'className') {\n                    node.className = processClasses(properties[propKey]);\n                } else if (previousProperties[propKey] !== properties[propKey]) {\n                    node[propKey] = properties[propKey];\n                }\n            }\n        }\n    };\n\n    /**\n     * Sets the value for multiple styles on a node.\n     *\n     * @param  {Object} node   \n     * @param  {Object} oldStyle\n     * @param  {Object} newStyle\n     */\n    var processStyles = function processStyles(node, oldStyle, newStyle) {\n\n        var style = node.style;\n\n        if (oldStyle != null) {\n            if (newStyle == null) {\n\n                /**\n                 * newStyle is empty, remove all styles from oldStyle.\n                 */\n                var oldAttr;\n\n                for (oldAttr in oldStyle) {\n                    style.cssText = oldStyle[oldAttr];\n                }\n            } else {\n                if (oldStyle && typeof oldStyle === 'string') {\n                    style.cssText = '';\n                }\n\n                /**\n                 * Remove and updateVNode styles\n                 */\n\n                var styleAttr;\n\n                for (styleAttr in oldStyle) {\n\n                    if (newStyle[styleAttr]) {\n                        style[styleAttr] = newStyle[styleAttr];\n                    } else {\n                        style[styleAttr] = '';\n                    }\n                }\n\n                /**\n                 * Insert new styles\n                 */\n                for (styleAttr in newStyle) {\n\n                    if (!oldStyle[styleAttr]) {\n                        style[styleAttr] = newStyle[styleAttr];\n                    }\n                }\n            }\n        } else if (newStyle != null) {\n\n            var newAttr;\n\n            if (typeof newStyle === 'object') {\n                /**\n                 * oldStyle is empty, insert all styles from newStyle\n                 */\n                for (newAttr in newStyle) {\n                    style[newAttr] = newStyle[newAttr];\n                }\n            } else {\n                style.cssText = newStyle;\n            }\n        }\n    };\n\n    var patchAttributes = function patchAttributes(node, attrs, previousAttr) {\n\n        var attrKey;\n\n        if (previousAttr) {\n            for (attrKey in previousAttr) {\n\n                if (!previousAttr[attrKey] || attrs && attrs[attrKey] != null) {\n                    continue;\n                }\n                if (attrKey === 'style') {\n                    processStyles(node, previousAttr[attrKey]);\n                } else if (specialAttrs.unset[attrKey]) {\n                    specialAttrs.unset[attrKey](attrKey, node, previousAttr);\n                } else {\n                    node.removeAttribute(attrKey);\n                }\n            }\n        }\n\n        if (attrs) {\n            for (attrKey in attrs) {\n                if (attrKey === 'class') {\n                    if (attrs[attrKey] != null) {\n                        node.setAttribute(attrKey, processClasses(attrs[attrKey]));\n                    }\n                } else if (attrKey === 'style') {\n                    processStyles(node, previousAttr ? previousAttr[attrKey] : undefined, attrs[attrKey]);\n                } else if (attrKey === 'value') {\n                    previousAttr = previousAttr || {};\n                    if (previousAttr[attrKey] !== attrs[attrKey]) {\n                        node.setAttribute(attrKey, attrs[attrKey]);\n                        node[attrKey] = attrs[attrKey] ? attrs[attrKey] : '';\n                    }\n                } else if (specialAttrs[attrKey]) {\n                    specialAttrs.set(attrKey, node, attrs, previousAttr || {});\n                } else if (attrs[attrKey] != null && previousAttr[attrKey] !== attrs[attrKey]) {\n                    node.setAttribute(attrKey, attrs[attrKey]);\n                }\n            }\n        }\n    };\n\n    var patch = function patch(to) {\n\n        // Only patch if the nodes are equal\n        if (this.equalTo(to)) {\n\n            // Special case - select\n            if (this.tagName === 'select') {\n                renderSelect(to);\n            }\n\n            // Update properties\n            patchProperties(this.node, to.props, this.props);\n\n            // Update attributes\n            patchAttributes(this.node, to.attrs, this.attrs);\n\n            // Update children\n\n            if (this.children !== to.children) {\n                var root = this.node.shadowRoot ? this.node.shadowRoot : this.node;\n\n                updateChildren(root, this.children, to.children);\n            }\n\n            if (to.events) {\n                this.node.__root__ = to;\n            } else if (this.events) {\n                this.node.__root__ = undefined;\n            }\n\n            if (this.callbacks && this.callbacks.updated) {\n                this.callbacks.updated(this, this.node);\n            }\n\n            return to.node = this.node;\n        }\n\n        this.detach(false);\n\n        return to.render(this.parent);\n    };\n\n    /**\r\n     * Removes the DOM node attached to the virtual node.\r\n     */\n    var prototype_detach = function prototype_detach(destroy) {\n\n        if (this.children && this.children.length) {\n\n            if (this.children.length === 1) {\n\n                if (this.children[0].callbacks && this.children[0].callbacks.detach) {\n                    this.children[0].callbacks.detach(this, this.children[0].node);\n                }\n            } else {\n\n                var i = 0,\n                    node = undefined,\n                    len = this.children.length;\n\n                for (; i < len; i++) {\n\n                    node = this.children[i];\n\n                    if (node.callbacks && node.callbacks.detach) {\n                        node.callbacks.detach(node, node.node);\n                    }\n                }\n            }\n        }\n\n        if (this.callbacks && this.callbacks.detach) {\n            this.callbacks.detach(this, this.node);\n        }\n\n        if (destroy !== false) {\n            this.destroy();\n        }\n    };\n\n    /**\n      * Checks if two virtual nodes are equal to each other, and they can be updated.\n      *\n      * @param {Object} node\n      * @return {boolean}\n      */\n    var equalTo = function equalTo(node) {\n        return !(this.key !== node.key || // \"key\" highest priority in \"patching\"\n        this.tagName !== node.tagName || this.type !== node.type || this.namespace !== node.namespace || this.is !== node.is);\n    };\n\n    var init = function init(tagName, options, children) {\n\n        options = options || {};\n\n        /**\r\n         * Tag contain tag name of the virtual node\r\n         */\n        this.tagName = tagName || 'div';\n\n        /**\r\n         * List of children nodes. \r\n         */\n        this.children = children || [];\n\n        /**\r\n         * Properties\r\n         */\n        this.props = options.props || {};\n\n        /**\r\n         * Attributes\r\n         */\n        this.attrs = options.attrs;\n\n        /**\r\n         * Events\r\n         */\n        this.events = options.events;\n\n        /**\r\n         * Callbacks / lifecycle hooks\r\n         */\n        this.callbacks = options.callbacks;\n\n        /**\r\n         * Reference to the virtual node \r\n         */\n        this.node = undefined;\n\n        /**\r\n         * Reference to the parent node \r\n         */\n        this.parent = undefined;\n\n        /**\r\n         * Add data \r\n         */\n        this.data = options.data;\n\n        /**\r\n         * Key Used for sorting/replacing during diffing\r\n         */\n        this.key = options.key || null;\n        /**\r\n         * Namespace for xlink and xml attributes\r\n         */\n        this.namespace = options.attrs && options.attrs.xmlns || null;\n        /**\r\n         * is - custom elements / attributes, and type extensions\r\n         */\n        this.is = options.attrs && options.attrs.is || null;\n        /**\r\n         * Reference to the virtual node's type\r\n         */\n        this.type = ELEMENT;\n    };\n\n    function Element(tagName, options, children) {\n        this.init(tagName, options, children);\n    }\n\n    Element.prototype = {\n        attach: prototype_attach,\n        create: create,\n        toHTML: toHTML,\n        render: render,\n        patch: patch,\n        destroy: prototype_destroy,\n        detach: prototype_detach,\n        equalTo: equalTo,\n        init: init\n    };\n\n    /** Export */\n\n    /**\n     * Initialize the virtual tree\n     */\n    var prototype_init = function prototype_init() {\n        /** Container to hold all mounted virtual trees. */\n        this.mountContainer = {};\n    };\n\n    /**\r\n     * Mounts a virtual tree into a passed selector.\r\n     *\r\n     * @param {String|Object}   selector\r\n     * @param {Function|Object} factory\r\n     * @param {Object}          data\r\n     */\n    var prototype_mount = function prototype_mount(selector, factory, data) {\n        return this.apply(selector, factory, data, function (root, nodes) {\n\n            if (typeof nodes === 'function') {\n                nodes = nodes(root);\n            }\n\n            if (!(nodes instanceof Array)) {\n                nodes = [nodes];\n            }\n\n            // Render children\n            if (nodes.length) {\n                // ignore incompatible children\n                if (nodes.length === 1 && nodes[0]) {\n                    root.appendChild(nodes[0].render());\n                } else {\n                    var i = 0,\n                        len = nodes.length;\n                    for (; i < len; i++) {\n                        if (nodes[i]) {\n                            root.appendChild(nodes[i].render());\n                        }\n                    }\n                }\n            }\n\n            return nodes;\n        });\n    };\n\n    var unmount = function unmount(uuid) {\n        if (arguments.length) {\n            var mount = this.mountContainer[uuid];\n\n            if (mount) {\n                detach(mount.children);\n                delete mount.root.virtualTreeID;\n                delete this.mountContainer[uuid];\n            }\n        } else {\n            // Remove the world. Unmount everything.\n            for (uuid in this.mountContainer) {\n                this.unmount(uuid);\n            }\n        }\n    };\n\n    var update = function update(root, prevNodes, nodes, parent) {\n\n        if (typeof nodes === 'function') {\n            nodes = nodes(root, parent);\n        }\n\n        if (!(nodes instanceof Array)) {\n            nodes = [nodes];\n        }\n\n        return updateChildren(root, prevNodes, nodes, parent);\n    };\n\n    var prototype_update = function prototype_update(mountId, tree) {\n\n        if (arguments.length) {\n\n            var mount = this.mountContainer[mountId];\n\n            if (mount) {\n                // Make sure focus is never lost\n                var activeElement = document.activeElement;\n\n                mount.children = update(mount.root, mount.children, tree ? tree : mount.factory);\n\n                if (document.activeElement !== activeElement) {\n                    activeElement.focus();\n                }\n            }\n        } else {\n\n            for (mountId in this.mountContainer) {\n                this.update(mountId);\n            }\n        }\n    };\n\n    var mounted = function mounted(uuid) {\n        return arguments.length ? this.mountContainer[uuid] : this.mountContainer;\n    };\n\n    /**\n     * Find a DOM node by it's CSS selector\n     *\n     * @param {String|DOMElement} selector\n     * @param {DOMElement|null} element\n     * @return {DOMElement} The node where to mount the virtual tree\n     */\n    var findDOMNode = function findDOMNode(selector, element) {\n\n        if (element == null) {\n            element = document;\n        }\n\n        if (typeof selector === 'string') {\n            var quickMatch = /^(?:(\\w+)|\\.([\\w\\-]+))$/.exec(selector);\n            return quickMatch ? element.getElementsByClassName(quickMatch[2])[0] : element.querySelector(selector);\n        }\n\n        if (selector.nodeType === 1) {\n            return selector;\n        }\n    };\n\n    // Generate a unique identifier\n    var uuidFunc = function uuidFunc(char) {\n        return char == 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0 & 0x3 | 0x8).toString(16);\n    };\n    var guid = function guid() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, uuidFunc);\n    };\n\n    var apply = function apply(selector, factory, container, children) {\n\n        // Find the selector where we are going to mount the virtual tree\n        var root = findDOMNode(selector),\n            mountId;\n\n        if (root) {\n\n            container = container || {};\n\n            // Unmount if already mounted\n            if (root.virtualTreeID) {\n                this.unmount(root.virtualTreeID);\n            }\n\n            mountId = container.mountId ? container.mountId : guid();\n\n            container.root = root;\n            container.factory = factory;\n            container.children = children(root, factory, null);\n\n            this.mountContainer[mountId] = container;\n\n            return root.virtualTreeID = mountId;\n        }\n    };\n\n    var Tree_prototype_attach = function Tree_prototype_attach(selector, factory, data) {\n        return this.apply(selector, factory, data, attach);\n    };\n\n    var prototype_guid = function prototype_guid() {\n        return guid();\n    };\n\n    var Tree = function Tree() {\n        this.init();\n    };\n\n    Tree.prototype = {\n        init: prototype_init,\n        apply: apply,\n        attach: Tree_prototype_attach,\n        mount: prototype_mount,\n        unmount: unmount,\n        update: prototype_update,\n        mounted: mounted,\n        guid: prototype_guid\n    };\n\n    var core_patch = function core_patch(anchorNode, finaleNode) {\n\n        var node = anchorNode.node;\n\n        if (anchorNode === finaleNode) {\n            return node;\n        }\n\n        var patchedNode = anchorNode.patch(finaleNode);\n\n        // prevent unnecessary replaceChild calls\n        if (patchedNode !== node) {\n\n            // replace the 'patched' node with the old one\n            if (node.parentElement) {\n                node.parentElement.replaceChild(patchedNode, node);\n            }\n        }\n        return patchedNode;\n    };\n\n    var EventManager_prototype_init = function EventManager_prototype_init(delegateHandler, container) {\n\n        this.eventHandler = delegateHandler;\n        this.context = container || document.body; // Default to document body\n        this.eventContainer = [];\n    };\n\n    /**\n     * Bind an event `type` to a callback function\n     *\n     * @param {Element} node\n     * @param {String} type\n     * @param {Function} callback\n     * @param {Boolean} useCapture\n     */\n\n    var addEventListener = function addEventListener(node, type, callback, useCapture) {\n        node.addEventListener(type, callback, useCapture || false);\n    };\n\n    var bubbleEvent = function bubbleEvent(root, type) {\n\n        return function (e) {\n\n            e.isPropagationStopped = false;\n            e.delegateTarget = e.target;\n            e.stopPropagation = function () {\n                this.isPropagationStopped = true;\n            };\n\n            while (e.delegateTarget && e.delegateTarget !== root.eventHandler) {\n                root.eventHandler(type, e);\n                if (e.isPropagationStopped) {\n                    break;\n                }\n                e.delegateTarget = e.delegateTarget.parentNode;\n            }\n        };\n    };\n\n    /**\r\n     * Bind an bubbled event on a DOM node.\r\n     *\r\n     * NOTE: The listener will be invoked with a normalized event object.\r\n     *\r\n     * @param {String} type\r\n     * @param {Boolean} useCapture\r\n     */\n    var bind = function bind(type, useCapture) {\n\n        var evt = bubbleEvent(this, type);\n\n        // remove the 'event type' if the event are bind already\n        if (this.eventContainer[type]) {\n            this.unbind(type);\n        }\n\n        this.eventContainer[type] = evt;\n        addEventListener(this.context, type, this.eventContainer[type], useCapture || false);\n\n        return evt;\n    };\n\n    /**\n     * Unbind an event `type`' to a callback function\n     * @param {Element} node\n     * @param {String} type\n     * @param {Function} callback\n     * @param {Boolean} useCapture\n     */\n    var removeEventListener = function removeEventListener(node, type, callback, useCapture) {\n        node.removeEventListener(type, callback, useCapture || false);\n    };\n\n    var unbind = function unbind(type, useCapture) {\n\n        if (arguments.length) {\n            if (this.eventContainer[type]) {\n                removeEventListener(this.context, type, this.eventContainer[type], useCapture || false);\n            }\n        } else {\n\n            var events;\n\n            // Unbind all events\n            for (events in this.eventContainer) {\n                this.unbind(events);\n            }\n        }\n    };\n\n    /**\n     * Returns all events we are listening to\n     *\n     * @return Array\n     */\n    var listeners = function listeners() {\n        return Object.keys(this.eventContainer);\n    };\n\n    /**\r\n     * List of common events.\r\n     */\n    var commonEvents = ('blur change click contextmenu copy cut dblclick drag dragend dragenter dragexit dragleave dragover dragstart ' + 'drop focus input keydown keyup keypress mousedown mousemove mouseout mouseover mouseup paste scroll submit ' + 'touchcancel touchend touchmove touchstart wheel').split(' ');\n\n    var bindDefaultEvents = function bindDefaultEvents() {\n        var _this = this;\n\n        each(commonEvents, function (evt) {\n            _this.bind(evt);\n        });\n    };\n\n    var EventManager = function EventManager(delegateHandler, container) {\n        this.init(delegateHandler, container);\n    };\n\n    EventManager.prototype = {\n        init: EventManager_prototype_init,\n        bind: bind,\n        unbind: unbind,\n        listeners: listeners,\n        bindDefaultEvents: bindDefaultEvents\n    };\n\n    var _EventManager = EventManager;\n\n    // In XML (and XML-based languages such as XHTML), tagName preserves case. On HTML elements in\n    // DOM trees flagged as HTML documents, tagName returns the element name in the uppercase form.\n    /**\n     * Return 'nodeName' in lowerCase()\n     * @return {String|Null}\n     */\n    var getNodeName = function getNodeName(node) {\n        return node.nodeName.toLowerCase();\n    };\n\n    var rreturn = /\\r/g;\n\n    var getEventValues = function getEventValues(node, value) {\n\n        var type = node.getAttribute('type') == null ? getNodeName(node) : node.getAttribute('type');\n\n        if (arguments.length === 1) {\n\n            if (type === 'checkbox' || type === 'radio') {\n\n                if (!node.checked) {\n                    return false;\n                }\n\n                var val = node.getAttribute('value');\n\n                return val == null ? true : val;\n            } else if (type === 'select') {\n\n                if (node.multiple) {\n\n                    var result = [];\n\n                    each(node.options, function (option) {\n                        if (option.selected &&\n                        // Don't return options that are disabled or in a disabled optgroup\n                        option.getAttribute('disabled') === null && (!option.parentNode.disabled || getNodeName(option.parentNode) !== 'optgroup')) {\n                            result.push(option.value || option.text);\n                        }\n                    });\n\n                    return result;\n                }\n                return ~node.selectedIndex ? node.options[node.selectedIndex].value : '';\n            }\n        }\n\n        var ret = node.value;\n        return typeof ret === 'string' ?\n        // Handle most common string cases\n        ret.replace(rreturn, '') :\n        // Handle cases where value is null/undef or number\n        ret == null ? '' : ret;\n    };\n\n    var genericHandler = function genericHandler(eventName, ev) {\n\n        var node = ev.delegateTarget,\n            value;\n\n        eventName = 'on' + eventName;\n\n        if (node.__root__ && (node.__root__.events && node.__root__.events[eventName])) {\n\n            switch (getNodeName(node)) {\n\n                case 'input':\n                case 'select':\n                case 'radio':\n                case 'button':\n                case 'textarea':\n                    value = getEventValues(node);\n\n                    break;\n            }\n\n            return node.__root__.events[eventName](ev, value);\n        }\n    };\n\n    var EventHandler;\n\n    var initEvent = function initEvent() {\n\n        if (!EventHandler) {\n\n            EventHandler = new _EventManager(genericHandler);\n\n            EventHandler.bindDefaultEvents();\n        }\n        return EventHandler;\n    };\n\n    var Trackira = {\n\n        Element: Element,\n        Comment: Comment,\n        Text: Text,\n        Tree: Tree,\n        detach: detach,\n        updateChildren: updateChildren,\n        patch: core_patch,\n        update: update,\n        attach: attach,\n        initEvent: initEvent\n    };\n\n    Trackira.version = '0.1.1a';\n\n    var trackira = Trackira;\n\n    return trackira;\n});\n//# sourceMappingURL=./trackira.js.map","'use strict';\n\nvar Executor = require('./executor');\n\nfunction Benchmark() {\n  this.running = false;\n  this.impl = null;\n  this.tests = null;\n  this.reportCallback = null;\n\n  this.container = document.createElement('div');\n\n  this._runButton = document.getElementById('RunButton');\n  this._iterationsElement = document.getElementById('Iterations');\n  this._reportElement = document.createElement('pre');\n\n  document.body.appendChild(this.container);\n  document.body.appendChild(this._reportElement);\n\n  var self = this;\n\n  this._runButton.addEventListener('click', function(e) {\n    e.preventDefault();\n\n    if (!self.running) {\n      var iterations = parseInt(self._iterationsElement.value);\n      if (iterations <= 0) {\n        iterations = 10;\n      }\n\n      self.run(iterations);\n    }\n  }, false);\n\n  this.ready(true);\n}\n\nBenchmark.prototype.ready = function(v) {\n  if (v) {\n    this._runButton.disabled = '';\n  } else {\n    this._runButton.disabled = 'true';\n  }\n};\n\nBenchmark.prototype.run = function(iterations) {\n  var self = this;\n  this.running = true;\n  this.ready(false);\n\n  new Executor(self.impl, self.container, self.tests, 1, function() { // warmup\n    new Executor(self.impl, self.container, self.tests, iterations, function(samples) {\n      self._reportElement.textContent = JSON.stringify(samples, null, ' ');\n      self.running = false;\n      self.ready(true);\n      if (self.reportCallback != null) {\n        self.reportCallback(samples);\n      }\n    }).start();\n  }).start();\n};\n\nmodule.exports = Benchmark;\n","'use strict';\n\nfunction Executor(impl, container, tests, iterations, cb, iterCb) {\n  if (iterCb === void 0) iterCb = null;\n\n  this.impl = impl;\n  this.container = container;\n  this.tests = tests;\n  this.iterations = iterations;\n  this.cb = cb;\n  this.iterCb = iterCb;\n\n  this._currentTest = 0;\n  this._currentIter = 0;\n  this._renderSamples = [];\n  this._updateSamples = [];\n  this._result = [];\n\n  this._tasksCount = tests.length * iterations;\n\n  this._iter = this.iter.bind(this);\n}\n\nExecutor.prototype.start = function() {\n  this._iter();\n};\n\nExecutor.prototype.finished = function() {\n  this.cb(this._result);\n};\n\nExecutor.prototype.progress = function() {\n  if (this._currentTest === 0 && this._currentIter === 0) {\n    return 0;\n  }\n\n  var tests = this.tests;\n  return (this._currentTest * tests.length + this._currentIter) / (tests.length * this.iterataions);\n};\n\nExecutor.prototype.iter = function() {\n  if (this.iterCb != null) {\n    this.iterCb(this);\n  }\n\n  var tests = this.tests;\n\n  if (this._currentTest < tests.length) {\n    var test = tests[this._currentTest];\n\n    if (this._currentIter < this.iterations) {\n      var e, t;\n      var renderTime, updateTime;\n\n      e = new this.impl(this.container, test.data.a, test.data.b);\n      e.setUp();\n\n      t = window.performance.now();\n      e.render();\n      renderTime = window.performance.now() - t;\n\n      t = window.performance.now();\n      e.update();\n      updateTime = window.performance.now() - t;\n      e.tearDown();\n\n      this._renderSamples.push(renderTime);\n      this._updateSamples.push(updateTime);\n\n      this._currentIter++;\n    } else {\n      this._result.push({\n        name: test.name + ' ' + 'render()',\n        data: this._renderSamples.slice(0)\n      });\n\n      this._result.push({\n        name: test.name + ' ' + 'update()',\n        data: this._updateSamples.slice(0)\n      });\n\n      this._currentTest++;\n\n      this._currentIter = 0;\n      this._renderSamples = [];\n      this._updateSamples = [];\n    }\n\n    setTimeout(this._iter, 0);\n  } else {\n    this.finished();\n  }\n};\n\nmodule.exports = Executor;\n","'use strict';\n\nvar Benchmark = require('./benchmark');\nvar benchmark = new Benchmark();\n\nfunction initFromScript(scriptUrl, impl) {\n  var e = document.createElement('script');\n  e.src = scriptUrl;\n\n  e.onload = function() {\n    benchmark.tests = window.benchmarkTests();\n    benchmark.ready(true);\n  };\n\n  document.head.appendChild(e);\n}\n\nfunction initFromParentWindow(parent, name, version, id) {\n  window.addEventListener('message', function(e) {\n    var data = e.data;\n    var type = data.type;\n\n    if (type === 'tests') {\n      benchmark.tests = data.data;\n      benchmark.reportCallback = function(samples) {\n        parent.postMessage({\n          type: 'report',\n          data: {\n            name: name,\n            version: version,\n            samples: samples\n          },\n          id: id\n        }, '*');\n      };\n      benchmark.ready(true);\n\n      parent.postMessage({\n        type: 'ready',\n        data: null,\n        id: id\n      }, '*');\n    } else if (type === 'run') {\n      benchmark.run(data.data.iterations);\n    }\n  }, false);\n\n  parent.postMessage({\n    type: 'init',\n    data: null,\n    id: id\n  }, '*');\n}\n\nfunction init(name, version, impl) {\n  // Parse Query String.\n  var qs = (function(a) {\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n      var p=a[i].split('=', 2);\n      if (p.length == 1) {\n        b[p[0]] = \"\";\n      } else {\n        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n      }\n    }\n    return b;\n  })(window.location.search.substr(1).split('&'));\n\n  if (qs['name'] !== void 0) {\n    name = qs['name'];\n  }\n\n  if (qs['version'] !== void 0) {\n    version = qs['version'];\n  }\n\n  var type = qs['type'];\n  var id;\n  if (type === 'iframe') {\n    id = qs['id'];\n    if (id === void 0) id = null;\n    initFromParentWindow(window.parent, name, version, id);\n  } else if (type === 'window') {\n    if (window.opener != null) {\n      id = qs['id'];\n      if (id === void 0) id = null;\n      initFromParentWindow(window.opener, name, version, id);\n    } else {\n      console.log('Failed to initialize: opener window is NULL');\n    }\n  } else {\n    var testsUrl = qs['data']; // url to the script generating test data\n    if (testsUrl !== void 0) {\n      initFromScript(testsUrl);\n    } else {\n      console.log('Failed to initialize: cannot load tests data');\n    }\n  }\n\n  benchmark.impl = impl;\n}\n\n// performance.now() polyfill\n// https://gist.github.com/paulirish/5438650\n// prepare base perf object\nif (typeof window.performance === 'undefined') {\n  window.performance = {};\n}\nif (!window.performance.now){\n  var nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n  window.performance.now = function now(){\n    return Date.now() - nowOffset;\n  };\n}\n\nmodule.exports = init;\n"]}