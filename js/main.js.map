{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","web/js/main.js","node_modules/trackira/dist/trackira.js","node_modules/vdom-benchmark-base/lib/benchmark.js","node_modules/vdom-benchmark-base/lib/executor.js","node_modules/vdom-benchmark-base/lib/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar benchmark = require('vdom-benchmark-base');\nvar t = require('trackira');\n\nvar NAME = 'Trackira';\nvar VERSION = t.version;\n\nfunction renderTree(nodes) {\n    var children = [];\n    var i;\n    var e;\n    var n;\n\n    for (i = 0; i < nodes.length; i++) {\n        n = nodes[i];\n        if (n.children !== null) {\n            children.push(new t.Element('div', {key: n.key}, renderTree(n.children)));\n        } else {\n            children.push(new t.Element('span', {key: n.key}, [new t.Text(n.key.toString())]));\n        }\n    }\n\n    return children;\n}\n\nfunction BenchmarkImpl(container, a, b) {\n    this.container = container;\n    this.a = a;\n    this.b = b;\n    this._node = null;\n}\n\nBenchmarkImpl.prototype.setUp = function() {\n};\n\nBenchmarkImpl.prototype.tearDown = function() {\n    this._node.destroy();\n};\n\nBenchmarkImpl.prototype.render = function() {\n    this._node = new t.Element('div', null, renderTree(this.a));\n    this._node.render();\n};\n\nBenchmarkImpl.prototype.update = function() {\n    t.patch(this._node, new t.Element('div', {}, renderTree(this.b)));\n};\n\ndocument.addEventListener('DOMContentLoaded', function(e) {\n    benchmark(NAME, VERSION, BenchmarkImpl);\n}, false);","/**\n * trackira - Virtual DOM boilerplate\n * @Version: v0.1.3\n * @Author: Kenny Flashlight\n * @Homepage: http://trackira.github.io/trackira/\n * @License: MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Trackira = factory();\n})(this, function () {\n\t'use strict';\n\n\t// Type indicating that the virtual node is a Text node\n\tvar types__TEXT = 0x0001;\n\t// Type indicating that the virtual node is a Element node\n\tvar types__ELEMENT = 0x0002;\n\t// Type indicating that the virtual node is a Comment node\n\tvar types__COMMENT = 0x0003;\n\n\tvar ampRegEx = /&/g,\n\t    lessThanRegEx = /</g;\n\n\t// Don't escape unnecessary symbols\n\t// &lt;> is still not a valid HTML tags\n\tvar escapeHtml = function escapeHtml(value) {\n\t\treturn String(value).replace(ampRegEx, '&amp;').replace(lessThanRegEx, '&lt;');\n\t};\n\n\tfunction Text(text) {\n\n\t\tthis.text = '' + text;\n\t\tthis.type = types__TEXT;\n\t}\n\n\tText.prototype = {\n\n\t\t/**\n   * Render and return a virtual text node\n   *\n   * @return Object\n   */\n\t\trender: function render() {\n\n\t\t\tif (!this.node) {\n\n\t\t\t\tthis.node = document.createTextNode(this.text);\n\t\t\t}\n\n\t\t\treturn this.node;\n\t\t},\n\n\t\t/**\n   * Attaches an existing textual DOM element.\n   *\n   * @param  {Object} node\n   * @return {Object}\n   */\n\t\tattach: function attach(node) {\n\n\t\t\treturn this.node = node;\n\t\t},\n\n\t\t/**\n   * Patches the node by updating the nodeValue.\n   *\n   * @param {object} node Contains the next text content.\n   * @return {Object}\n   */\n\t\tpatch: function patch(node) {\n\n\t\t\tif (this.equalTo(node)) {\n\n\t\t\t\t// .nodeValue gives better performance then textContent\n\t\t\t\t// http://jsperf.com/update-textcontent-vs-data-vs-nodevalue\n\t\t\t\tif (node.text !== this.text) {\n\n\t\t\t\t\tthis.node.nodeValue = node.text;\n\t\t\t\t}\n\n\t\t\t\treturn node.node = this.node;\n\t\t\t}\n\n\t\t\t// If not the same, destroy the node\n\t\t\tthis.destroy();\n\t\t\t// ... and re-render\n\t\t\tnode.render();\n\t\t},\n\n\t\t/**\n   * Removes the text node attached to the virtual node.\n   */\n\t\tdetach: function detach() {\n\n\t\t\tthis.destroy();\n\t\t},\n\n\t\t/**\n   * Creates an html markup of the text node. This node is not intended to have\n   * any features besides containing text content.\n   */\n\t\ttoHTML: function toHTML() {\n\n\t\t\treturn escapeHtml(this.text);\n\t\t},\n\n\t\t/**\n   * Detach the text node attached to the virtual node.\n   */\n\t\tdestroy: function destroy() {\n\n\t\t\tvar node = this.node;\n\t\t\tif (node.parentNode) {\n\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Checks if two virtual text nodes are equal to each other, and they can be updated.\n   *\n   * @param {Object} node\n   * @return {boolean}\n   */\n\t\tequalTo: function equalTo(node) {\n\n\t\t\treturn this.type === node.type;\n\t\t}\n\t};\n\n\tfunction Comment(commentText) {\n\n\t\tthis.commentText = '' + commentText;\n\t\tthis.type = types__COMMENT;\n\t}\n\n\tComment.prototype = {\n\n\t\t/**\n   * Render and return a virtual comment node\n   *\n   * @return Object\n   */\n\t\trender: function render() {\n\n\t\t\tif (!this.node) {\n\n\t\t\t\tthis.node = document.createComment(this.commentText);\n\t\t\t\treturn this.node;\n\t\t\t}\n\t\t},\n\t\t/**\n   * Patches the node by updating the nodeValue.\n   *\n   * @param {object} node Contains the next text content.\n   * @return {Object}\n   */\n\t\tpatch: function patch(node) {\n\n\t\t\tif (this.equalTo(node)) {\n\n\t\t\t\t// .nodeValue gives better performance then textContent\n\t\t\t\t// http://jsperf.com/update-textcontent-vs-data-vs-nodevalue\n\t\t\t\tif (node.commentText !== this.commentText) {\n\n\t\t\t\t\tthis.node.nodeValue = node.commentText;\n\t\t\t\t}\n\t\t\t\treturn node.node = this.node;\n\t\t\t}\n\n\t\t\t// If not the same, destroy the node\n\t\t\tthis.destroy();\n\t\t\t// ... and re-render\n\t\t\tnode.render();\n\t\t},\n\n\t\t/**\n   * Attaches an existing textual DOM element.\n   *\n   * @param  {Object} node\n   * @return {Object}\n   */\n\t\tattach: function attach(node) {\n\n\t\t\treturn this.node = node;\n\t\t},\n\n\t\t/**\n   * Returns an html representation of the comment node.\n   */\n\t\ttoHTML: function toHTML() {\n\n\t\t\treturn '<!-- ' + this.commentText.replace(/^\\s+|\\s+$/gm, '') + ' -->';\n\t\t},\n\n\t\t/**\n   * Destroys the comment node attached to the virtual node.\n   */\n\t\tdestroy: function destroy() {\n\n\t\t\tvar node = this.node;\n\n\t\t\tif (node.parentNode) {\n\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Detach the comment node attached to the virtual node.\n   */\n\t\tdetach: function detach() {\n\n\t\t\tthis.destroy();\n\t\t},\n\n\t\t/**\n   * Checks if two virtual comment nodes are equal to each other, and if they can be updated.\n   *\n   * @param {Object} node\n   * @return {boolean}\n   */\n\t\tequalTo: function equalTo(node) {\n\n\t\t\treturn this.type === node.type;\n\t\t}\n\t};\n\n\t/** Export */\n\n\tvar attach = function attach(root, nodes, parent) {\n\n\t\tif (typeof nodes === 'function') {\n\n\t\t\tnodes = nodes(root, parent);\n\t\t}\n\n\t\tif (!(nodes instanceof Array)) {\n\n\t\t\tnodes = [nodes];\n\t\t}\n\n\t\tvar i = 0,\n\t\t    j = 0,\n\t\t    childNodes = root.childNodes,\n\t\t    nodesLen = nodes.length,\n\t\t    text,\n\t\t    textLen,\n\t\t    size;\n\n\t\twhile (i < nodesLen) {\n\n\t\t\tif (!nodes[i]) {\n\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// VIRTUAL COMMENT NODE\n\n\t\t\tif (nodes[i].type === types__COMMENT) {\n\n\t\t\t\t// comment node\n\n\t\t\t\tsize = nodes[i].commentText.length;\n\t\t\t\ttext = childNodes[j].data;\n\n\t\t\t\tnodes[i].commentText = text;\n\t\t\t\tnodes[i].attach(childNodes[j], parent);\n\t\t\t\ti++;\n\n\t\t\t\ttextLen = text.length;\n\n\t\t\t\twhile (size < textLen && i < nodesLen) {\n\n\t\t\t\t\tsize += nodes[i].commentText.length;\n\t\t\t\t\tnodes[i].commentText = '';\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\t// VIRTUAL TEXT NODE\n\t\t\t} else if (nodes[i].type === types__TEXT) {\n\n\t\t\t\tsize = nodes[i].text.length;\n\t\t\t\ttext = childNodes[j].data;\n\n\t\t\t\tnodes[i].text = text;\n\t\t\t\tnodes[i].attach(childNodes[j], parent);\n\t\t\t\ti++;\n\n\t\t\t\ttextLen = text.length;\n\n\t\t\t\twhile (size < textLen && i < nodesLen) {\n\n\t\t\t\t\tsize += nodes[i].text.length;\n\t\t\t\t\tnodes[i].text = '';\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\t// ALL OTHERS...\n\t\t\t} else {\n\n\t\t\t\tnodes[i].attach(childNodes[j], parent);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\treturn nodes;\n\t};\n\n\t/**\n   * Combines multiple className strings into one.\n   *\n   * @param {String|Number|Object} className\n   * @return {string}\n   */\n\tvar processClasses = function processClasses(className) {\n\n\t\tif (typeof className === 'string' || typeof className === 'number') {\n\n\t\t\treturn className;\n\t\t}\n\n\t\tif (typeof className === 'object') {\n\n\t\t\tvar key,\n\t\t\t    classes = '';\n\n\t\t\tfor (key in className) {\n\n\t\t\t\tif (className[key]) {\n\n\t\t\t\t\tclasses += ' ' + key;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/88\n\t\t\treturn classes.substr(1);\n\t\t}\n\t};\n\n\tvar renderProperties = function renderProperties(node, props) {\n\n\t\tvar propKey, propValue;\n\n\t\tfor (propKey in props) {\n\n\t\t\tpropValue = props[propKey];\n\t\t\tif (propKey === 'className' && propValue !== undefined) {\n\n\t\t\t\tnode.className = processClasses(propValue);\n\t\t\t} else if (propValue !== undefined) {\n\n\t\t\t\tnode[propKey] = propValue;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar prototype_attach = function prototype_attach(node) {\n\n\t\tthis.node = node;\n\n\t\t// Render properties\n\t\trenderProperties(node, this.props);\n\n\t\t// Render children   \n\t\tif (this.children.length) {\n\n\t\t\tattach(node, this.children, this);\n\t\t}\n\n\t\t// Handle events\n\t\tif (this.events) {\n\n\t\t\tnode.__root__ = this;\n\t\t}\n\n\t\t// Handle callbacks\n\t\tif (this.callbacks && this.callbacks.created) {\n\n\t\t\tthis.callbacks.created(this, node);\n\t\t}\n\n\t\treturn node;\n\t};\n\n\t/**\n  * Create root level element of the virtual node.\n  *\n  * @return {Object}\n  */\n\tvar create = function create() {\n\n\t\tif (this.namespace) {\n\n\t\t\treturn this.is ? document.createElementNS(this.namespace, this.tagName, this.is) : document.createElementNS(this.namespace, this.tagName);\n\t\t}\n\t\t// custom element/web component support\n\t\treturn this.is ? document.createElement(this.tagName, this.is) : document.createElement(this.tagName);\n\t};\n\n\t// For HTML, certain tags should omit their close tag. We keep a whitelist for\n\t// those special cased tags\n\n\tvar voidElementNames = {\n\t\t'area': true,\n\t\t'base': true,\n\t\t'br': true,\n\t\t'col': true,\n\t\t'command': true,\n\t\t'embed': true,\n\t\t'hr': true,\n\t\t'img': true,\n\t\t'input': true,\n\t\t'keygen': true,\n\t\t'link': true,\n\t\t//    \"menuitem\": true,\n\t\t'meta': true,\n\t\t'param': true,\n\t\t'source': true,\n\t\t'track': true,\n\t\t'wbr': true\n\t\t// NOTE: menuitem's close tag should be omitted, but that causes problems.\n\t};\n\n\t/**\n  *  Creates markup for HTML class / className attribute / properties\n  *\n  * @param {Object} value\n  * @return {String}\n  * @example\n  *\n  * new Trackira.Element(\"div\", attrs: { class: { \"foo\":true, \"bar\":false, \"baz\":true } }).toHTML();\n  *\n  * Result:  <div class=\"foo baz\"></div>   // \"bar\" are skipped because it's a falsy value\n  */\n\tvar createMarkupForClass = function createMarkupForClass(value) {\n\n\t\tif (typeof value === 'string') {\n\n\t\t\treturn value;\n\t\t}\n\n\t\tvar key,\n\t\t    markup = '';\n\n\t\tfor (key in value) {\n\n\t\t\t// the value will only be stringified if the value itself is true\n\t\t\tif (value[key]) {\n\n\t\t\t\tmarkup += key + ' ';\n\t\t\t}\n\t\t}\n\t\treturn markup.trim();\n\t};\n\n\t/**\n  *  Creates markup for CSS style values\n  *\n  * @param {Object} styles\n  * @return {String}\n  */\n\tvar createMarkupForStyles = function createMarkupForStyles(styles) {\n\n\t\tif (typeof styles === 'object') {\n\n\t\t\tvar styleName,\n\t\t\t    styleValue,\n\t\t\t    serialized = '';\n\t\t\tfor (styleName in styles) {\n\n\t\t\t\tif (styles[styleName]) {\n\n\t\t\t\t\tstyleValue = styles[styleName];\n\t\t\t\t\tif (styleValue !== undefined) {\n\n\t\t\t\t\t\tserialized += styleName + ':';\n\t\t\t\t\t\tserialized += typeof styleValue === 'number' ? styleValue + 'px' : styleValue;\n\t\t\t\t\t\tserialized += ';';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn serialized;\n\t\t}\n\t\treturn styles;\n\t};\n\n\tvar createMarkupForAttributes = function createMarkupForAttributes(attrs, tagName) {\n\n\t\tvar markup = '',\n\t\t    attrKey,\n\t\t    attrValue;\n\n\t\tfor (attrKey in attrs) {\n\n\t\t\tif (attrKey !== 'innerHTML') {\n\n\t\t\t\tattrValue = attrs[attrKey];\n\n\t\t\t\tif (attrValue) {\n\n\t\t\t\t\t// Special case: \"style\"\n\t\t\t\t\tif (attrKey === 'style') {\n\n\t\t\t\t\t\tattrValue = createMarkupForStyles(attrValue);\n\t\t\t\t\t}\n\t\t\t\t\t// Special case: \"class\"\n\t\t\t\t\tif (attrKey === 'class') {\n\n\t\t\t\t\t\tattrValue = createMarkupForClass(attrValue);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Special case - select and textarea values (should not be stringified)\n\t\t\t\t\t//              - contenteditable should be ignored\n\t\t\t\t\tif (!(attrKey === 'value' && (tagName === 'textarea' || tagName === 'select' || attrs.contenteditable))) {\n\n\t\t\t\t\t\tmarkup += ' ' + attrKey + '=\"' + '' + attrValue + '\"';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn markup;\n\t};\n\n\tvar whitelist = {\n\t\t/**\n   * Standard Properties\n   */\n\t\taccept: true,\n\t\tacceptCharset: true,\n\t\taccessKey: true,\n\t\taction: true,\n\t\tallowFullScreen: 1,\n\t\tallowTransparency: true,\n\t\talt: true,\n\t\tasync: 1,\n\t\tautocomplete: true,\n\t\tautofocus: 1,\n\t\tautoplay: 1,\n\t\tcapture: 1,\n\t\tcellPadding: true,\n\t\tcellSpacing: true,\n\t\tcharset: true,\n\t\tchallenge: true,\n\t\tchecked: 1,\n\t\tclassID: true,\n\t\tclassName: true,\n\t\tcols: true,\n\t\tcolSpan: true,\n\t\tcontent: true,\n\t\tcontentEditable: true,\n\t\tcontextMenu: true,\n\t\tcontrols: 1,\n\t\tcoords: true,\n\t\tcrossOrigin: true,\n\t\tcurrentTime: true,\n\t\tdata: true,\n\t\tdateTime: true,\n\t\tdefer: 1,\n\t\tdir: true,\n\t\tdisabled: 1,\n\t\tdownload: 2,\n\t\tdraggable: true,\n\t\tenctype: true,\n\t\tform: true,\n\t\tformAction: true,\n\t\tformEncType: true,\n\t\tformMethod: true,\n\t\tformNoValidate: 1,\n\t\tformTarget: true,\n\t\tframeBorder: true,\n\t\theaders: true,\n\t\theight: true,\n\t\thidden: 1,\n\t\thref: true,\n\t\threflang: true,\n\t\thtmlFor: true,\n\t\thttpEquiv: true,\n\t\ticon: true,\n\t\tid: true,\n\t\tis: true,\n\t\tkeyParams: true,\n\t\tkeyType: true,\n\t\tlabel: true,\n\t\tlang: true,\n\t\tlist: true,\n\t\tloop: 1,\n\t\tlow: true,\n\t\tmanifest: true,\n\t\tmarginHeight: true,\n\t\tmarginWidth: true,\n\t\tmax: true,\n\t\tmaxLength: true,\n\t\tmedia: true,\n\t\tmediaGroup: true,\n\t\tmethod: true,\n\t\tmin: true,\n\t\tminLength: true,\n\t\tmultiple: 1,\n\t\tmuted: 1,\n\t\tname: true,\n\t\tnoValidate: 1,\n\t\topen: true,\n\t\toptimum: true,\n\t\tpattern: true,\n\t\tplaceholder: true,\n\t\tplaybackRate: true,\n\t\tposter: true,\n\t\tpreload: true,\n\t\tradiogroup: true,\n\t\treadOnly: 1,\n\t\trel: true,\n\t\trequired: 1,\n\t\trole: true,\n\t\trows: true,\n\t\trowSpan: true,\n\t\tsandbox: true,\n\t\tscope: true,\n\t\tscoped: 1,\n\t\tscrolling: true,\n\t\tseamless: 1,\n\t\tselected: 1,\n\t\tshape: true,\n\t\tsize: true,\n\t\tsizes: true,\n\t\tspan: true,\n\t\tspellcheck: true,\n\t\tsrc: true,\n\t\tsrcdoc: true,\n\t\tsrcset: true,\n\t\tsrcObject: true,\n\t\tstart: true,\n\t\tstep: true,\n\t\tstyle: true,\n\t\ttabIndex: true,\n\t\ttarget: true,\n\t\ttitle: true,\n\t\ttype: true,\n\t\tuseMap: true,\n\t\tvalue: true,\n\t\tvolume: true,\n\t\twidth: true,\n\t\twmode: true,\n\n\t\t/**\n   * Non-standard Properties\n   */\n\t\t// autoCapitalize and autoCorrect are supported in Mobile Safari for\n\t\t// keyboard hints.\n\t\tautocapitalize: true,\n\t\tautocorrect: true,\n\t\t// itemProp, itemScope, itemType are for Microdata support. See\n\t\t// http://schema.org/docs/gs.html\n\t\titemProp: true,\n\t\titemScope: 1,\n\t\titemType: true,\n\t\t// itemID and itemRef are for Microdata support as well but\n\t\t// only specified in the the WHATWG spec document. See\n\t\t// https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api\n\t\titemID: true,\n\t\titemRef: true,\n\t\t// property is supported for OpenGraph in meta tags.\n\t\tproperty: true,\n\t\t// IE-only attribute that controls focus behavior\n\t\tunselectable: true\n\t};\n\n\tvar attributeNames = {\n\t\tacceptCharset: 'accept-charset',\n\t\tclassName: 'class',\n\t\thtmlFor: 'for',\n\t\thttpEquiv: 'http-equiv'\n\t};\n\n\tvar createAttribute = function createAttribute(key, value) {\n\n\t\tkey = (attributeNames[key] || key).toLowerCase();\n\n\t\tvar attrType = whitelist[key];\n\n\t\t// a boolean `value` has to be truthy\n\t\t// and a overloaded boolean `value` has to be === true\n\t\tif (attrType === 1 || attrType === 2 && value === true) {\n\n\t\t\treturn escapeHtml(key);\n\t\t}\n\t\treturn key + '=\"' + '' + value + '\"';\n\t};\n\n\tvar createMarkupForProperties = function createMarkupForProperties(props) {\n\n\t\tvar markup = '',\n\t\t    attr,\n\t\t    propValue,\n\t\t    propKey;\n\n\t\tfor (propKey in props) {\n\n\t\t\tif (propKey !== 'innerHTML') {\n\n\t\t\t\tpropValue = props[propKey];\n\n\t\t\t\tif (propValue) {\n\n\t\t\t\t\t// Special case: \"style\"\n\t\t\t\t\tif (propKey === 'style') {\n\n\t\t\t\t\t\tpropValue = createMarkupForStyles(propValue);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Special case: \"class\"\n\t\t\t\t\tif (propKey === 'className') {\n\n\t\t\t\t\t\tpropValue = createMarkupForClass(propValue);\n\t\t\t\t\t}\n\n\t\t\t\t\tattr = createAttribute(propKey, propValue);\n\n\t\t\t\t\tif (attr) {\n\n\t\t\t\t\t\tmarkup += ' ' + attr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn markup;\n\t};\n\n\tvar toHTML = function toHTML() {\n\n\t\tvar node = this,\n\t\t    tagName = node.tagName.toLowerCase(),\n\t\t    html = '<' + tagName;\n\n\t\t// stringify attributes\n\t\tif (node.attrs) {\n\n\t\t\thtml += createMarkupForAttributes(node.attrs, node.tagName);\n\t\t}\n\n\t\t// stringify properties\n\t\tif (node.props) {\n\n\t\t\thtml += createMarkupForProperties(node.props);\n\t\t}\n\n\t\thtml = html + '>';\n\n\t\t// stringify children\n\t\tif (node.children.length) {\n\n\t\t\tif (node.children.length === 1) {\n\n\t\t\t\thtml += node.children[0].toHTML();\n\t\t\t} else {\n\n\t\t\t\tvar i = 0,\n\t\t\t\t    len = node.children.length;\n\t\t\t\tfor (; i < len; i++) {\n\n\t\t\t\t\thtml += node.children[i].toHTML();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// process innerHTML\n\t\t} else if (node.props && node.props.innerHTML) {\n\n\t\t\thtml += node.props.innerHTML;\n\t\t}\n\n\t\t// add a closing tag if this isn't a void element\n\t\treturn html += voidElementNames[tagName] ? '' : '</' + tagName + '>';\n\t};\n\n\t/**\n  * Get namespace\n  *\n  * @param  {String} tagName\n  * @param  {Object} parentNode\n  * @return {String}\n  */\n\tvar getNamespace = function getNamespace(tagName, parentNode) {\n\n\t\t// Use SVG namespace, if this is an <svg> element\n\t\tif (tagName === 'svg') {\n\n\t\t\treturn 'http://www.w3.org/2000/svg';\n\t\t}\n\n\t\t// ...or MATH namespace, if this is an <math> element\n\t\tif (tagName === 'math') {\n\n\t\t\treturn 'http://www.w3.org/1998/Math/MathML';\n\t\t}\n\n\t\t// ...or inherit from the parent node\n\t\tif (parentNode) {\n\n\t\t\treturn parentNode.namespace;\n\t\t}\n\t};\n\n\tvar determineNameAndNamespace = function determineNameAndNamespace(value) {\n\n\t\tvar colonIndex, namespacePrefix, namespace;\n\n\t\t// are we dealing with a namespaced attribute, e.g. xlink:href?\n\t\tcolonIndex = value.indexOf(':');\n\n\t\tif (colonIndex !== -1) {\n\n\t\t\t// looks like we are, yes...\n\t\t\tnamespacePrefix = value.substr(0, colonIndex);\n\n\t\t\tvalue = value.substring(colonIndex + 1);\n\n\t\t\tswitch (namespacePrefix) {\n\n\t\t\t\tcase 'xlink':\n\t\t\t\t\tnamespace = 'http://www.w3.org/1999/xlink';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'xml':\n\t\t\t\t\tnamespace = 'http://www.w3.org/XML/1998/namespace';\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tname: value,\n\t\t\t\tnamespace: namespace,\n\t\t\t\tnamespacePrefix: namespacePrefix\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n  * Invokes the `callback` function once for each item in `arr` collection,\n  * which can only be an array.\n  *\n  * @param {Array} collection\n  * @param {Function} callback\n  * @return {Array}\n  * @private\n  */\n\tvar each = function each(collection, callback) {\n\n\t\tvar arr = collection || [],\n\t\t    index = -1,\n\t\t    length = arr.length;\n\n\t\twhile (++index < length) {\n\n\t\t\tcallback(arr[index], index, arr);\n\t\t}\n\t\treturn arr;\n\t};\n\n\tvar // xlink namespace attributes\n\txlinkAttributes = 'xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type'.split(' '),\n\t   \n\t// xml namespace attributes\n\txmlAttributes = 'xml:base xml:id xml:lang xml:space'.split(' '),\n\t   \n\t// boolean attributes\n\tbools = 'multiple,selected,checked,disabled,readOnly,required,open'.split(','),\n\t    hook = { set: {}, unset: {} };\n\n\t// setter & getter for 'xlink' namespace attributes\n\teach(xlinkAttributes, function (key) {\n\n\t\thook.set[key] = function (name, node, attrs, previous) {\n\n\t\t\tif (attrs[name] || previous && previous[name] !== attrs[name]) {\n\n\t\t\t\tvar namespace = determineNameAndNamespace(name);\n\t\t\t\tnode.setAttributeNS(namespace.namespace, namespace.name, attrs[name]);\n\t\t\t}\n\t\t};\n\n\t\thook.unset[key] = function (name, node, previous) {\n\n\t\t\tvar namespace = determineNameAndNamespace(key);\n\t\t\tnode.removeAttributeNS(namespace.namespace, namespace.name);\n\t\t};\n\t});\n\n\t// setter & getter for 'xml' namespace attributes\n\teach(xmlAttributes, function (key) {\n\n\t\thook.set[key] = function (name, node, attrs, previous) {\n\n\t\t\tif (attrs[name] || previous && previous[name] !== attrs[name]) {\n\n\t\t\t\tvar namespace = determineNameAndNamespace(key);\n\t\t\t\tnode.setAttributeNS(namespace.namespace, namespace.name, attrs[name]);\n\t\t\t}\n\t\t};\n\n\t\thook.unset[key] = function (name, node, previous) {\n\n\t\t\t// Namespace attributes\n\t\t\tvar namespace = determineNameAndNamespace(key);\n\t\t\tnode.removeAttributeNS(namespace.namespace, namespace.name);\n\t\t};\n\t});\n\n\t// setter for boolean attributes\n\teach(bools, function (key) {\n\n\t\thook.set[key] = function (name, node, attrs, previous) {\n\n\t\t\tif (attrs[name] || previous && previous[name] !== attrs[name]) {\n\n\t\t\t\t// Only set boolean attributes if the value is not negative\n\t\t\t\tif (attrs[name]) {\n\n\t\t\t\t\tnode.setAttribute(key, attrs[name]);\n\t\t\t\t\tnode[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\n\tvar specialAttrs = hook;\n\n\tvar renderAttributes = function renderAttributes(node, attrs) {\n\n\t\tvar attrName, attributeValue, attrValue, styleName;\n\n\t\tfor (attrName in attrs) {\n\n\t\t\tattrValue = attrs[attrName];\n\t\t\tif (attrValue !== undefined) {\n\n\t\t\t\tif (attrName === 'style') {\n\n\t\t\t\t\tif (typeof attrValue === 'object') {\n\n\t\t\t\t\t\tfor (styleName in attrValue) {\n\n\t\t\t\t\t\t\tattributeValue = attrValue[styleName];\n\t\t\t\t\t\t\tif (attributeValue) {\n\n\t\t\t\t\t\t\t\tnode.style[styleName] = '' + attributeValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof attrValue === 'string') {\n\n\t\t\t\t\t\tnode.style.cssText = attrValue;\n\t\t\t\t\t}\n\t\t\t\t} else if (attrName === 'value') {\n\n\t\t\t\t\tif (attrValue != null) {\n\n\t\t\t\t\t\tnode.setAttribute(attrName, attrValue);\n\t\t\t\t\t\tnode.value = attrValue;\n\t\t\t\t\t}\n\t\t\t\t} else if (attrName === 'class') {\n\n\t\t\t\t\tnode.setAttribute(attrName, processClasses(attrValue));\n\t\t\t\t} else if (specialAttrs.set[attrName]) {\n\n\t\t\t\t\tspecialAttrs.set[attrName](attrName, node, attrs, {});\n\t\t\t\t} else {\n\n\t\t\t\t\tnode.setAttribute(attrName, attrValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar processOption = function processOption(vnode, values) {\n\n\t\tif (vnode.tagName === 'option') {\n\n\t\t\tif (values[vnode.attrs && vnode.attrs.value]) {\n\n\t\t\t\tvnode.attrs = vnode.attrs || {};\n\t\t\t\tvnode.attrs.selected = 'selected';\n\t\t\t} else if (values[vnode.props && vnode.props.value]) {\n\n\t\t\t\tvnode.props = vnode.props || {};\n\t\t\t\tvnode.props.selected = true;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// stringify children\n\t\t\tif (vnode.children.length) {\n\n\t\t\t\tif (vnode.children.length === 1) {\n\n\t\t\t\t\tprocessOption(vnode.children[0], values);\n\t\t\t\t} else {\n\n\t\t\t\t\tvar i = 0,\n\t\t\t\t\t    len = vnode.children.length;\n\t\t\t\t\tfor (; i < len; i++) {\n\n\t\t\t\t\t\tprocessOption(vnode.children[i], values);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar renderSelect = function renderSelect(node) {\n\n\t\tvar selectValue = node.attrs && node.attrs.value || node.props && node.props.value,\n\t\t    values = {};\n\n\t\t// If the <select> has a specified value, that should override\n\t\t// these options\n\t\tif (selectValue !== undefined) {\n\n\t\t\tif (selectValue instanceof Array) {\n\n\t\t\t\tvar i = 0,\n\t\t\t\t    value;\n\n\t\t\t\twhile (i < selectValue.length) {\n\n\t\t\t\t\tvalue = selectValue[i++];\n\t\t\t\t\tvalues[value] = value;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tvalues[selectValue] = selectValue;\n\t\t\t}\n\n\t\t\tprocessOption(node, values);\n\t\t}\n\t};\n\n\tvar render = function render(parent) {\n\n\t\tif (parent) {\n\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\t// Set valid namespace\n\t\tif (this.namespace == null) {\n\n\t\t\tthis.namespace = getNamespace(this.tagName, parent) || null;\n\t\t}\n\n\t\t// create a new virtual element\n\t\tvar node = this.node = this.create(),\n\t\t    children = this.children;\n\n\t\t// Special case - select\n\t\tif (this.tagName === 'select') {\n\n\t\t\trenderSelect(this);\n\t\t}\n\n\t\t// Render properties\n\t\trenderProperties(node, this.props);\n\n\t\t// Render attributes\n\t\trenderAttributes(node, this.attrs);\n\n\t\t// Render children\n\t\tif (this.children.length) {\n\n\t\t\t// ignore incompatible children\n\t\t\tif (this.children.length === 1 && children[0]) {\n\n\t\t\t\tnode.appendChild(children[0].render(this));\n\t\t\t} else {\n\n\t\t\t\tvar i = 0,\n\t\t\t\t    len = children.length;\n\t\t\t\tfor (; i < len; i++) {\n\n\t\t\t\t\tif (children[i]) {\n\n\t\t\t\t\t\tnode.appendChild(children[i].render(this));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// only attach the vnode reference for DOM element which has defined events to minimize overhead\n\t\tif (this.events) {\n\n\t\t\tnode.__root__ = this;\n\t\t}\n\n\t\t// Handle callbacks\n\t\tif (this.callbacks && this.callbacks.created) {\n\n\t\t\tthis.callbacks.created(this, node);\n\t\t}\n\n\t\treturn node;\n\t};\n\n\t/**\n  * Remove a real DOM element from where it was inserted\n  */\n\tvar prototype_destroy = function prototype_destroy() {\n\n\t\tvar node = this.node,\n\t\t    parentElement;\n\n\t\tif (node) {\n\n\t\t\t// need to check for parent node - DOM may have been altered\n\t\t\t// by something other than Trackira! e.g. jQuery UI...\n\t\t\tif (parentElement = node.parentElement) {\n\n\t\t\t\tif (!this.callbacks || !this.callbacks.destroy) {\n\n\t\t\t\t\treturn parentElement.removeChild(node);\n\t\t\t\t}\n\n\t\t\t\tthis.callbacks.destroy(node, function () {\n\n\t\t\t\t\tparentElement.removeChild(node);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// should silently abort if the element has no parent\n\t\t}\n\t};\n\n\t//import detach        from \"../core/detach\";\n\t//import insertChildAt from \"../core/insertChildAt\";\n\n\tfunction keysIndexes(fromChildren, startIndex, endIndex) {\n\t\tvar i,\n\t\t    keys = {},\n\t\t    key;\n\n\t\tif (endIndex === 1) {\n\n\t\t\tkey = fromChildren[0].key;\n\t\t\tif (key !== undefined) {\n\t\t\t\tkeys[key] = 0;\n\t\t\t}\n\t\t} else {\n\n\t\t\tfor (i = endIndex; i >= startIndex; i--) {\n\t\t\t\tkey = fromChildren[i].key;\n\t\t\t\tif (key !== undefined) {\n\t\t\t\t\tkeys[key] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n\n\tvar updateChildren = function updateChildren(container, fromChildren, toChildren, parent) {\n\n\t\tvar fromStartIndex = 0,\n\t\t    toStartIndex = 0,\n\t\t    fromEndIndex = fromChildren.length - 1,\n\t\t    fromStartNode = fromChildren[0],\n\t\t    fromEndNode = fromChildren[fromEndIndex],\n\t\t    toEndIndex = toChildren.length - 1,\n\t\t    toStartNode = toChildren[0],\n\t\t    toEndNode = toChildren[toEndIndex],\n\t\t    indexes,\n\t\t    index,\n\t\t    node,\n\t\t    before;\n\n\t\tvar updated = false;\n\n\t\tif (fromChildren != null && fromEndIndex > -1) {\n\n\t\t\tif (toChildren == null || toChildren.length === 0) {\n\n\t\t\t\tfor (; fromStartIndex <= fromEndIndex; fromStartIndex++) {\n\n\t\t\t\t\tif (fromChildren[fromStartIndex] !== undefined) {\n\t\t\t\t\t\tfromChildren[fromStartIndex].detach();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (fromEndIndex < 2 && toEndIndex < 2) {\n\n\t\t\t\t\t// Implicit key with same type or explicit key with same key.\n\t\t\t\t\tif (fromStartNode.key == null && fromStartNode.equalTo(toStartNode) || fromStartNode.key != null && fromStartNode.key === toStartNode.key) {\n\t\t\t\t\t\tfromStartNode.patch(toStartNode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfromStartNode.detach();\n\t\t\t\t\t\tcontainer.appendChild(toStartNode.render());\n\t\t\t\t\t}\n\t\t\t\t} else if (fromChildren.length === 1) {\n\n\t\t\t\t\twhile (toStartIndex <= toEndIndex) {\n\n\t\t\t\t\t\ttoStartNode = toChildren[toStartIndex++];\n\t\t\t\t\t\tif (fromStartNode.key == null && fromStartNode.equalTo(toStartNode) || fromStartNode.key != null && fromStartNode.key === toStartNode.key) {\n\n\t\t\t\t\t\t\tfromStartNode.patch(toStartNode);\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontainer.insertBefore(toStartNode.render(), fromStartNode.node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (updated) {\n\t\t\t\t\t\twhile (toStartIndex < toChildren.length) {\n\t\t\t\t\t\t\tcontainer.appendChild(toChildren[toStartIndex++].render());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfromStartNode.detach();\n\t\t\t\t\t}\n\t\t\t\t} else if (toChildren.length === 1) {\n\n\t\t\t\t\twhile (fromStartIndex <= fromEndIndex) {\n\n\t\t\t\t\t\tfromStartNode = fromChildren[fromStartIndex++];\n\t\t\t\t\t\tif (toStartNode.key == null && toStartNode.equalTo(fromStartNode) || toStartNode.key != null && toStartNode.key === fromStartNode.key) {\n\n\t\t\t\t\t\t\ttoStartNode.patch(fromStartNode);\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfromStartNode.detach();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (updated) {\n\t\t\t\t\t\twhile (fromStartIndex < fromChildren.length) {\n\t\t\t\t\t\t\tfromChildren[fromStartIndex++].detach();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainer.appendChild(toChildren[0].render());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\twhile (fromStartIndex <= fromEndIndex && toStartIndex <= toEndIndex) {\n\n\t\t\t\t\t\tif (fromStartNode === undefined) {\n\t\t\t\t\t\t\tfromStartNode = fromChildren[++fromStartIndex];\n\t\t\t\t\t\t} else if (fromEndNode === undefined) {\n\t\t\t\t\t\t\tfromEndNode = fromChildren[--fromEndIndex];\n\t\t\t\t\t\t} else if (fromStartNode.equalTo(toStartNode)) {\n\t\t\t\t\t\t\tfromStartNode.patch(toStartNode);\n\t\t\t\t\t\t\tfromStartNode = fromChildren[++fromStartIndex];\n\t\t\t\t\t\t\ttoStartNode = toChildren[++toStartIndex];\n\t\t\t\t\t\t} else if (fromEndNode.equalTo(toEndNode)) {\n\t\t\t\t\t\t\tfromEndNode.patch(toEndNode);\n\t\t\t\t\t\t\tfromEndNode = fromChildren[--fromEndIndex];\n\t\t\t\t\t\t\ttoEndNode = toChildren[--toEndIndex];\n\t\t\t\t\t\t} else if (fromStartNode.equalTo(toEndNode)) {\n\t\t\t\t\t\t\tfromStartNode.patch(toEndNode);\n\t\t\t\t\t\t\tcontainer.insertBefore(fromStartNode.node, fromEndNode.node.nextSibling);\n\t\t\t\t\t\t\tfromStartNode = fromChildren[++fromStartIndex];\n\t\t\t\t\t\t\ttoEndNode = toChildren[--toEndIndex];\n\t\t\t\t\t\t} else if (fromEndNode.equalTo(toStartNode)) {\n\t\t\t\t\t\t\tfromEndNode.patch(toStartNode);\n\t\t\t\t\t\t\tcontainer.insertBefore(fromEndNode.node, fromStartNode.node);\n\t\t\t\t\t\t\tfromEndNode = fromChildren[--fromEndIndex];\n\t\t\t\t\t\t\ttoStartNode = toChildren[++toStartIndex];\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif (indexes === undefined) {\n\t\t\t\t\t\t\t\tindexes = keysIndexes(fromChildren, fromStartIndex, fromEndIndex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindex = indexes[toStartNode.key];\n\t\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\t\tcontainer.insertBefore(toStartNode.render(parent), fromStartNode.node);\n\t\t\t\t\t\t\t\ttoStartNode = toChildren[++toStartIndex];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnode = fromChildren[index];\n\t\t\t\t\t\t\t\tnode.patch(toStartNode);\n\t\t\t\t\t\t\t\tfromChildren[index] = undefined;\n\t\t\t\t\t\t\t\tcontainer.insertBefore(node.node, fromStartNode.node);\n\t\t\t\t\t\t\t\ttoStartNode = toChildren[++toStartIndex];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fromStartIndex > fromEndIndex) {\n\t\t\t\t\t\tbefore = toChildren[toEndIndex + 1] === undefined ? null : toChildren[toEndIndex + 1].node;\n\t\t\t\t\t\tfor (; toStartIndex <= toEndIndex; toStartIndex++) {\n\t\t\t\t\t\t\tcontainer.insertBefore(toChildren[toStartIndex].render(parent), before);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (toStartIndex > toEndIndex) {\n\n\t\t\t\t\t\tfor (; fromStartIndex <= fromEndIndex; fromStartIndex++) {\n\t\t\t\t\t\t\tif (fromChildren[fromStartIndex] !== undefined) {\n\t\t\t\t\t\t\t\tfromChildren[fromStartIndex].detach();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn toChildren;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar patchProperties = function patchProperties(node, props, prevProps) {\n\n\t\tvar propKey;\n\n\t\tif (prevProps) {\n\n\t\t\tfor (propKey in prevProps) {\n\n\t\t\t\tif (prevProps[propKey] !== undefined && props[propKey] === undefined) {\n\n\t\t\t\t\tif (propKey === 'className') {\n\n\t\t\t\t\t\tnode.className = '';\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode[propKey] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (props) {\n\n\t\t\tfor (propKey in props) {\n\n\t\t\t\tif (!prevProps || prevProps[propKey] !== props[propKey]) {\n\n\t\t\t\t\tif (propKey === 'className') {\n\n\t\t\t\t\t\tnode.className = processClasses(props[propKey]);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode[propKey] = props[propKey];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar patchAttributes = function patchAttributes(node, attrs, previousAttr) {\n\n\t\tvar propKey, styleName, attrName, previousAttrValue, attrValue, oldStyle, styleValue;\n\n\t\tif (previousAttr != null) {\n\t\t\tfor (attrName in previousAttr) {\n\n\t\t\t\tpreviousAttrValue = previousAttr[attrName];\n\n\t\t\t\tif (!previousAttrValue || attrs && attrs[attrName] != null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Unset styles on `previousAttr` but not on `attrs`.\n\t\t\t\tif (attrName === 'style') {\n\t\t\t\t\tfor (styleName in previousAttrValue) {\n\t\t\t\t\t\tnode.style[styleName] = '';\n\t\t\t\t\t}\n\t\t\t\t} else if (specialAttrs.unset[attrName]) {\n\n\t\t\t\t\tspecialAttrs.unset[attrName](attrName, node, previousAttr);\n\t\t\t\t} else {\n\n\t\t\t\t\tnode.removeAttribute(attrName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (attrs != null) {\n\t\t\tfor (attrName in attrs) {\n\n\t\t\t\tattrValue = attrs[attrName];\n\n\t\t\t\tif (attrName === 'style') {\n\n\t\t\t\t\toldStyle = previousAttr[attrName];\n\n\t\t\t\t\t// checking both for typeof \"string\" and \"object\", avoid\n\t\t\t\t\t// trouble with array etc.\n\t\t\t\t\tif (typeof attrValue === 'object') {\n\n\t\t\t\t\t\tif (typeof oldStyle === 'object') {\n\n\t\t\t\t\t\t\tfor (propKey in oldStyle) {\n\t\t\t\t\t\t\t\tnode.style[propKey] = '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Update styles that changed since `previousAttr`.\n\t\t\t\t\t\t\tfor (propKey in attrValue) {\n\t\t\t\t\t\t\t\tstyleValue = attrValue[propKey];\n\t\t\t\t\t\t\t\tnode.style[propKey] = styleValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif (oldStyle) {\n\t\t\t\t\t\t\t\tnode.style.cssText = '';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (propKey in attrValue) {\n\t\t\t\t\t\t\t\tstyleValue = attrValue[propKey];\n\t\t\t\t\t\t\t\tnode.style[propKey] = styleValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (attrName === 'class') {\n\t\t\t\t\tnode.setAttribute(attrName, processClasses(attrValue));\n\t\t\t\t} else if (previousAttr[attrName] !== attrValue) {\n\n\t\t\t\t\tif (attrName === 'value') {\n\n\t\t\t\t\t\tnode.setAttribute(attrName, attrValue);\n\t\t\t\t\t\tnode[attrName] = attrValue ? attrValue : '';\n\t\t\t\t\t} else if (attrValue != null) {\n\n\t\t\t\t\t\tnode.setAttribute(attrName, attrValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar patch = function patch(ref) {\n\n\t\t/** @type {HTMLElement} */\n\t\tvar node = ref.node = this.node;\n\n\t\t// Only patch if the nodes are equal\n\t\tif (this.equalTo(ref)) {\n\n\t\t\t// Special case - select\n\t\t\tif (this.tagName === 'select') {\n\n\t\t\t\trenderSelect(ref);\n\t\t\t}\n\n\t\t\t// Update properties\n\t\t\tpatchProperties(node, ref.props, this.props);\n\n\t\t\t// Update attributes\n\t\t\tpatchAttributes(node, ref.attrs, this.attrs);\n\n\t\t\t// Update children\n\t\t\tif (this.children !== ref.children) {\n\n\t\t\t\tupdateChildren(node, this.children, ref.children);\n\t\t\t}\n\n\t\t\t// Handle events\n\t\t\tif (ref.events) {\n\n\t\t\t\tnode.__root__ = ref;\n\t\t\t} else if (this.events) {\n\n\t\t\t\tnode.__root__ = undefined;\n\t\t\t}\n\n\t\t\t// Handle callbacks\n\t\t\tif (this.callbacks && this.callbacks.updated) {\n\n\t\t\t\tthis.callbacks.updated(this, node);\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\t\t// No equal node, detach the previous one\n\t\tthis.detach(false);\n\t\t// ... and render a new one\n\t\treturn ref.render(this.parent);\n\t};\n\n\t/**\n  * Removes the DOM node attached to the virtual node.\n  */\n\tvar detach = function detach(destroy) {\n\n\t\tif (this.children && this.children.length) {\n\n\t\t\tvar i = 0,\n\t\t\t    node = undefined,\n\t\t\t    len = this.children.length;\n\n\t\t\tfor (; i < len; i++) {\n\n\t\t\t\tnode = this.children[i];\n\n\t\t\t\tif (node.callbacks && node.callbacks.detach) {\n\n\t\t\t\t\tnode.callbacks.detach(node, node.node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks && this.callbacks.detach) {\n\n\t\t\tthis.callbacks.detach(this, this.node);\n\t\t}\n\n\t\tif (destroy !== false) {\n\n\t\t\tthis.destroy();\n\t\t}\n\t};\n\n\t/**\n   * Checks if two virtual nodes are equal to each other, and they can be updated.\n   *\n   * @param {Object} node\n   * @return {boolean}\n   */\n\tvar equalTo = function equalTo(node) {\n\n\t\treturn !(this.key !== node.key || // \"key\" highest priority in \"patching\"\n\t\tthis.tagName !== node.tagName || this.type !== node.type || this.namespace !== node.namespace || this.is !== node.is);\n\t};\n\n\tvar init = function init(tagName, options, children) {\n\n\t\toptions = options || {};\n\n\t\t/**\n   * Tag contain tag name of the virtual node\n   */\n\t\tthis.tagName = tagName || 'div';\n\n\t\t/**\n   * List of children nodes. \n   */\n\t\tthis.children = children || [];\n\n\t\t/**\n   * Properties\n   */\n\t\tthis.props = options.props || {};\n\n\t\t/**\n   * Attributes\n   */\n\t\tthis.attrs = options.attrs || {};\n\n\t\t/**\n   * Events\n   */\n\t\tthis.events = options.events;\n\n\t\t/**\n   * Callbacks / lifecycle hooks\n   */\n\t\tthis.callbacks = options.callbacks;\n\n\t\t/**\n   * Reference to the virtual node \n   */\n\n\t\t/**\n  * Reference to the virtual node. It will be available after the virtual node is\n  * created or patched. \n  */\n\t\tthis.node = null;\n\n\t\t/**\n   * Reference to the parent node \n   */\n\t\tthis.parent = null;\n\n\t\t/**\n   * Add data \n   */\n\t\tthis.data = options.data;\n\n\t\t/**\n   * Key Used for sorting/replacing during diffing\n   */\n\t\tthis.key = options.key || null;\n\t\t/**\n   * Namespace for xlink and xml attributes\n   */\n\t\tthis.namespace = options.attrs && options.attrs.xmlns || null;\n\t\t/**\n   * is - custom elements / attributes, and type extensions\n   */\n\t\tthis.is = options.attrs && options.attrs.is || null;\n\t\t/**\n   * Reference to the virtual node's type\n   */\n\t\tthis.type = types__ELEMENT;\n\t};\n\n\tfunction Element(tagName, options, children) {\n\n\t\tthis.init(tagName, options, children);\n\t}\n\n\tElement.prototype = {\n\t\tattach: prototype_attach,\n\t\tcreate: create,\n\t\ttoHTML: toHTML,\n\t\trender: render,\n\t\tpatch: patch,\n\t\tdestroy: prototype_destroy,\n\t\tdetach: detach,\n\t\tequalTo: equalTo,\n\t\tinit: init\n\t};\n\n\t/** Export */\n\n\t/**\n  * Initialize the virtual tree\n  */\n\tvar prototype_init = function prototype_init() {\n\n\t\t/** Container to hold all mounted virtual trees. */\n\t\tthis.mountContainer = {};\n\t};\n\n\t/**\n  * Mounts a virtual tree into a passed selector.\n  *\n  * @param {String|Object}   selector\n  * @param {Function|Object} factory\n  * @param {Object}          data\n  */\n\tvar prototype_mount = function prototype_mount(selector, factory, data) {\n\n\t\treturn this.apply(selector, factory, data, function (root, nodes) {\n\n\t\t\tif (typeof nodes === 'function') {\n\n\t\t\t\tnodes = nodes(root);\n\t\t\t}\n\n\t\t\tif (!(nodes instanceof Array)) {\n\n\t\t\t\tnodes = [nodes];\n\t\t\t}\n\n\t\t\t// Render children\n\t\t\tif (nodes.length) {\n\n\t\t\t\t// ignore incompatible children\n\t\t\t\tif (nodes.length === 1 && nodes[0]) {\n\n\t\t\t\t\troot.appendChild(nodes[0].render());\n\t\t\t\t} else {\n\n\t\t\t\t\tvar i = 0,\n\t\t\t\t\t    len = nodes.length;\n\t\t\t\t\tfor (; i < len; i++) {\n\n\t\t\t\t\t\tif (nodes[i]) {\n\n\t\t\t\t\t\t\troot.appendChild(nodes[i].render());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nodes;\n\t\t});\n\t};\n\n\t/**\n  * @module detach\n  */\n\tvar core_detach = function core_detach(nodes) {\n\n\t\tvar i = 0;\n\n\t\twhile (i < nodes.length) {\n\n\t\t\tnodes[i++].detach();\n\t\t}\n\t};\n\n\tvar unmount = function unmount(uuid) {\n\n\t\tif (arguments.length) {\n\n\t\t\tvar mount = this.mountContainer[uuid];\n\n\t\t\tif (mount) {\n\n\t\t\t\tcore_detach(mount.children);\n\t\t\t\tdelete mount.root.virtualTreeID;\n\t\t\t\tdelete this.mountContainer[uuid];\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Remove the world. Unmount everything.\n\t\t\tfor (uuid in this.mountContainer) {\n\n\t\t\t\tthis.unmount(uuid);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar update = function update(root, prevNodes, nodes, parent) {\n\n\t\tif (typeof nodes === 'function') {\n\n\t\t\tnodes = nodes(root, parent);\n\t\t}\n\n\t\tif (!(nodes instanceof Array)) {\n\n\t\t\tnodes = [nodes];\n\t\t}\n\n\t\treturn updateChildren(root, prevNodes, nodes, parent);\n\t};\n\n\tvar prototype_update = function prototype_update(mountId, tree) {\n\n\t\tif (arguments.length) {\n\n\t\t\tvar mount = this.mountContainer[mountId];\n\n\t\t\tif (mount) {\n\n\t\t\t\t// Make sure focus is never lost\n\t\t\t\tvar activeElement = document.activeElement;\n\n\t\t\t\tmount.children = update(mount.root, mount.children, tree ? tree : mount.factory);\n\n\t\t\t\tif (document.activeElement !== activeElement) {\n\n\t\t\t\t\tactiveElement.focus();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tfor (mountId in this.mountContainer) {\n\n\t\t\t\tthis.update(mountId);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar mounted = function mounted(uuid) {\n\n\t\treturn arguments.length ? this.mountContainer[uuid] : this.mountContainer;\n\t};\n\n\t/**\n  * Find a DOM node by it's CSS selector\n  *\n  * @param {String|DOMElement} selector\n  * @param {DOMElement|null} element\n  * @return {DOMElement} The node where to mount the virtual tree\n  */\n\tvar findDOMNode = function findDOMNode(selector, element) {\n\n\t\tif (element == null) {\n\n\t\t\telement = document;\n\t\t}\n\n\t\tif (typeof selector === 'string') {\n\n\t\t\tvar quickMatch = /^(?:(\\w+)|\\.([\\w\\-]+))$/.exec(selector);\n\t\t\treturn quickMatch ? element.getElementsByClassName(quickMatch[2])[0] : element.querySelector(selector);\n\t\t}\n\n\t\tif (selector.nodeType === 1) {\n\n\t\t\treturn selector;\n\t\t}\n\t};\n\n\t// Generate a unique identifier\n\tvar uuidFunc = function uuidFunc(char) {\n\t\treturn char == 'x' ? Math.random() * 16 | 0 : (Math.random() * 16 | 0 & 0x3 | 0x8).toString(16);\n\t};\n\tvar guid = function guid() {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, uuidFunc);\n\t};\n\n\tvar apply = function apply(selector, factory, container, children) {\n\n\t\t// Find the selector where we are going to mount the virtual tree\n\t\tvar root = findDOMNode(selector),\n\t\t    mountId;\n\n\t\tif (root) {\n\n\t\t\tcontainer = container || {};\n\n\t\t\t// Unmount if already mounted\n\t\t\tif (root.virtualTreeID) {\n\n\t\t\t\tthis.unmount(root.virtualTreeID);\n\t\t\t}\n\n\t\t\tmountId = container.mountId ? container.mountId : guid();\n\n\t\t\tcontainer.root = root;\n\t\t\tcontainer.factory = factory;\n\t\t\tcontainer.children = children(root, factory, null);\n\n\t\t\tthis.mountContainer[mountId] = container;\n\n\t\t\treturn root.virtualTreeID = mountId;\n\t\t}\n\t};\n\n\tvar Tree_prototype_attach = function Tree_prototype_attach(selector, factory, data) {\n\n\t\treturn this.apply(selector, factory, data, attach);\n\t};\n\n\tvar prototype_guid = function prototype_guid() {\n\n\t\treturn guid();\n\t};\n\n\tvar Tree = function Tree() {\n\n\t\tthis.init();\n\t};\n\n\tTree.prototype = {\n\t\tinit: prototype_init,\n\t\tapply: apply,\n\t\tattach: Tree_prototype_attach,\n\t\tmount: prototype_mount,\n\t\tunmount: unmount,\n\t\tupdate: prototype_update,\n\t\tmounted: mounted,\n\t\tguid: prototype_guid\n\t};\n\n\tvar core_patch = function core_patch(anchorNode, finaleNode) {\n\n\t\tvar node = anchorNode.node;\n\n\t\tif (anchorNode === finaleNode) {\n\n\t\t\treturn node;\n\t\t}\n\n\t\tvar patchedNode = anchorNode.patch(finaleNode);\n\n\t\t// prevent unnecessary replaceChild calls\n\t\tif (patchedNode !== node) {\n\n\t\t\t// replace the 'patched' node with the old one\n\t\t\tif (node.parentElement) {\n\n\t\t\t\tnode.parentElement.replaceChild(patchedNode, node);\n\t\t\t}\n\t\t}\n\t\treturn patchedNode;\n\t};\n\n\tvar events_prototype_init = function events_prototype_init(delegateHandler, container) {\n\n\t\tthis.eventHandler = delegateHandler;\n\t\tthis.context = container || document.body; // Default to document body\n\t\tthis.eventContainer = [];\n\t};\n\n\t/**\n  * Bind an event `type` to a callback function\n  *\n  * @param {Element} node\n  * @param {String} type\n  * @param {Function} callback\n  * @param {Boolean} useCapture\n  */\n\n\tvar addEventListener = function addEventListener(node, type, callback, useCapture) {\n\n\t\tnode.addEventListener(type, callback, useCapture || false);\n\t};\n\n\tvar bubbleEvent = function bubbleEvent(root, type) {\n\n\t\treturn function (e) {\n\n\t\t\te.isPropagationStopped = false;\n\t\t\te.delegateTarget = e.target;\n\t\t\te.stopPropagation = function () {\n\n\t\t\t\tthis.isPropagationStopped = true;\n\t\t\t};\n\n\t\t\twhile (e.delegateTarget && e.delegateTarget !== root.eventHandler) {\n\n\t\t\t\troot.eventHandler(type, e);\n\t\t\t\tif (e.isPropagationStopped) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\te.delegateTarget = e.delegateTarget.parentNode;\n\t\t\t}\n\t\t};\n\t};\n\n\t/**\n  * Bind an bubbled event on a DOM node.\n  *\n  * NOTE: The listener will be invoked with a normalized event object.\n  *\n  * @param {String} type\n  * @param {Boolean} useCapture\n  */\n\tvar bind = function bind(type, useCapture) {\n\n\t\tvar evt = bubbleEvent(this, type);\n\n\t\t// remove the 'event type' if the event are bind already\n\t\tif (this.eventContainer[type]) {\n\n\t\t\tthis.unbind(type);\n\t\t}\n\n\t\tthis.eventContainer[type] = evt;\n\t\taddEventListener(this.context, type, this.eventContainer[type], useCapture || false);\n\n\t\treturn evt;\n\t};\n\n\t/**\n  * Unbind an event `type`' to a callback function\n  * @param {Element} node\n  * @param {String} type\n  * @param {Function} callback\n  * @param {Boolean} useCapture\n  */\n\tvar removeEventListener = function removeEventListener(node, type, callback, useCapture) {\n\n\t\tnode.removeEventListener(type, callback, useCapture || false);\n\t};\n\n\tvar unbind = function unbind(type, useCapture) {\n\n\t\tif (arguments.length) {\n\n\t\t\tif (this.eventContainer[type]) {\n\n\t\t\t\tremoveEventListener(this.context, type, this.eventContainer[type], useCapture || false);\n\t\t\t}\n\t\t} else {\n\n\t\t\tvar events;\n\n\t\t\t// Unbind all events\n\t\t\tfor (events in this.eventContainer) {\n\n\t\t\t\tthis.unbind(events);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Returns all events we are listening to\n  *\n  * @return Array\n  */\n\tvar listeners = function listeners() {\n\n\t\treturn Object.keys(this.eventContainer);\n\t};\n\n\t/**\n  * List of common events.\n  */\n\tvar commonEvents = ('blur change click contextmenu copy cut dblclick drag dragend dragenter dragexit dragleave dragover dragstart ' + 'drop focus input keydown keyup keypress mousedown mousemove mouseout mouseover mouseup paste scroll submit ' + 'touchcancel touchend touchmove touchstart wheel').split(' ');\n\n\tvar bindDefaultEvents = function bindDefaultEvents() {\n\t\tvar _this = this;\n\n\t\teach(commonEvents, function (evt) {\n\n\t\t\t_this.bind(evt);\n\t\t});\n\t};\n\n\tvar events = function events(delegateHandler, container) {\n\n\t\tthis.init(delegateHandler, container);\n\t};\n\n\tevents.prototype = {\n\t\tinit: events_prototype_init,\n\t\tbind: bind,\n\t\tunbind: unbind,\n\t\tlisteners: listeners,\n\t\tbindDefaultEvents: bindDefaultEvents\n\t};\n\n\tvar _events = events;\n\n\t// In XML (and XML-based languages such as XHTML), tagName preserves case. On HTML elements in\n\t// DOM trees flagged as HTML documents, tagName returns the element name in the uppercase form.\n\t/**\n  * Return 'nodeName' in lowerCase()\n  * @return {String|Null}\n  */\n\tvar getNodeName = function getNodeName(node) {\n\t\treturn node.nodeName.toLowerCase();\n\t};\n\n\tvar rreturn = /\\r/g;\n\n\tvar getEventValues = function getEventValues(node, value) {\n\n\t\tvar type = node.getAttribute('type') == null ? getNodeName(node) : node.getAttribute('type');\n\n\t\tif (arguments.length === 1) {\n\n\t\t\tif (type === 'checkbox' || type === 'radio') {\n\n\t\t\t\tif (!node.checked) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar val = node.getAttribute('value');\n\n\t\t\t\treturn val == null ? true : val;\n\t\t\t} else if (type === 'select') {\n\n\t\t\t\tif (node.multiple) {\n\n\t\t\t\t\tvar result = [];\n\n\t\t\t\t\teach(node.options, function (option) {\n\n\t\t\t\t\t\tif (option.selected &&\n\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\toption.getAttribute('disabled') === null && (!option.parentNode.disabled || getNodeName(option.parentNode) !== 'optgroup')) {\n\n\t\t\t\t\t\t\tresult.push(option.value || option.text);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn ~node.selectedIndex ? node.options[node.selectedIndex].value : '';\n\t\t\t}\n\t\t}\n\n\t\tvar ret = node.value;\n\t\treturn typeof ret === 'string' ?\n\t\t// Handle most common string cases\n\t\tret.replace(rreturn, '') :\n\t\t// Handle cases where value is null/undef or number\n\t\tret == null ? '' : ret;\n\t};\n\n\tvar genericHandler = function genericHandler(eventName, ev) {\n\n\t\tvar node = ev.delegateTarget,\n\t\t    value;\n\n\t\teventName = 'on' + eventName;\n\n\t\tif (node.__root__ && (node.__root__.events && node.__root__.events[eventName])) {\n\n\t\t\tswitch (getNodeName(node)) {\n\n\t\t\t\tcase 'input':\n\t\t\t\tcase 'select':\n\t\t\t\tcase 'radio':\n\t\t\t\tcase 'button':\n\t\t\t\tcase 'textarea':\n\t\t\t\t\tvalue = getEventValues(node);\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn node.__root__.events[eventName](ev, value);\n\t\t}\n\t};\n\n\tvar _handler;\n\n\tvar initEvent = function initEvent() {\n\n\t\tif (!_handler) {\n\n\t\t\t_handler = new _events(genericHandler);\n\n\t\t\t_handler.bindDefaultEvents();\n\t\t}\n\t\treturn _handler;\n\t};\n\n\tvar Trackira = {\n\n\t\tElement: Element,\n\t\tComment: Comment,\n\t\tText: Text,\n\t\tTree: Tree,\n\t\tdetach: core_detach,\n\t\tupdateChildren: updateChildren,\n\t\tpatch: core_patch,\n\t\tupdate: update,\n\t\tattach: attach,\n\t\tinitEvent: initEvent\n\t};\n\n\tTrackira.version = '0.1.3';\n\n\tvar trackira = Trackira;\n\n\treturn trackira;\n});\n//# sourceMappingURL=./trackira.js.map","'use strict';\n\nvar Executor = require('./executor');\n\nfunction Benchmark() {\n  this.running = false;\n  this.impl = null;\n  this.tests = null;\n  this.reportCallback = null;\n\n  this.container = document.createElement('div');\n\n  this._runButton = document.getElementById('RunButton');\n  this._iterationsElement = document.getElementById('Iterations');\n  this._reportElement = document.createElement('pre');\n\n  document.body.appendChild(this.container);\n  document.body.appendChild(this._reportElement);\n\n  var self = this;\n\n  this._runButton.addEventListener('click', function(e) {\n    e.preventDefault();\n\n    if (!self.running) {\n      var iterations = parseInt(self._iterationsElement.value);\n      if (iterations <= 0) {\n        iterations = 10;\n      }\n\n      self.run(iterations);\n    }\n  }, false);\n\n  this.ready(true);\n}\n\nBenchmark.prototype.ready = function(v) {\n  if (v) {\n    this._runButton.disabled = '';\n  } else {\n    this._runButton.disabled = 'true';\n  }\n};\n\nBenchmark.prototype.run = function(iterations) {\n  var self = this;\n  this.running = true;\n  this.ready(false);\n\n  new Executor(self.impl, self.container, self.tests, 1, function() { // warmup\n    new Executor(self.impl, self.container, self.tests, iterations, function(samples) {\n      self._reportElement.textContent = JSON.stringify(samples, null, ' ');\n      self.running = false;\n      self.ready(true);\n      if (self.reportCallback != null) {\n        self.reportCallback(samples);\n      }\n    }).start();\n  }).start();\n};\n\nmodule.exports = Benchmark;\n","'use strict';\n\nfunction Executor(impl, container, tests, iterations, cb, iterCb) {\n  if (iterCb === void 0) iterCb = null;\n\n  this.impl = impl;\n  this.container = container;\n  this.tests = tests;\n  this.iterations = iterations;\n  this.cb = cb;\n  this.iterCb = iterCb;\n\n  this._currentTest = 0;\n  this._currentIter = 0;\n  this._renderSamples = [];\n  this._updateSamples = [];\n  this._result = [];\n\n  this._tasksCount = tests.length * iterations;\n\n  this._iter = this.iter.bind(this);\n}\n\nExecutor.prototype.start = function() {\n  this._iter();\n};\n\nExecutor.prototype.finished = function() {\n  this.cb(this._result);\n};\n\nExecutor.prototype.progress = function() {\n  if (this._currentTest === 0 && this._currentIter === 0) {\n    return 0;\n  }\n\n  var tests = this.tests;\n  return (this._currentTest * tests.length + this._currentIter) / (tests.length * this.iterataions);\n};\n\nExecutor.prototype.iter = function() {\n  if (this.iterCb != null) {\n    this.iterCb(this);\n  }\n\n  var tests = this.tests;\n\n  if (this._currentTest < tests.length) {\n    var test = tests[this._currentTest];\n\n    if (this._currentIter < this.iterations) {\n      var e, t;\n      var renderTime, updateTime;\n\n      e = new this.impl(this.container, test.data.a, test.data.b);\n      e.setUp();\n\n      t = window.performance.now();\n      e.render();\n      renderTime = window.performance.now() - t;\n\n      t = window.performance.now();\n      e.update();\n      updateTime = window.performance.now() - t;\n      e.tearDown();\n\n      this._renderSamples.push(renderTime);\n      this._updateSamples.push(updateTime);\n\n      this._currentIter++;\n    } else {\n      this._result.push({\n        name: test.name + ' ' + 'render()',\n        data: this._renderSamples.slice(0)\n      });\n\n      this._result.push({\n        name: test.name + ' ' + 'update()',\n        data: this._updateSamples.slice(0)\n      });\n\n      this._currentTest++;\n\n      this._currentIter = 0;\n      this._renderSamples = [];\n      this._updateSamples = [];\n    }\n\n    setTimeout(this._iter, 0);\n  } else {\n    this.finished();\n  }\n};\n\nmodule.exports = Executor;\n","'use strict';\n\nvar Benchmark = require('./benchmark');\nvar benchmark = new Benchmark();\n\nfunction initFromScript(scriptUrl, impl) {\n  var e = document.createElement('script');\n  e.src = scriptUrl;\n\n  e.onload = function() {\n    benchmark.tests = window.benchmarkTests();\n    benchmark.ready(true);\n  };\n\n  document.head.appendChild(e);\n}\n\nfunction initFromParentWindow(parent, name, version, id) {\n  window.addEventListener('message', function(e) {\n    var data = e.data;\n    var type = data.type;\n\n    if (type === 'tests') {\n      benchmark.tests = data.data;\n      benchmark.reportCallback = function(samples) {\n        parent.postMessage({\n          type: 'report',\n          data: {\n            name: name,\n            version: version,\n            samples: samples\n          },\n          id: id\n        }, '*');\n      };\n      benchmark.ready(true);\n\n      parent.postMessage({\n        type: 'ready',\n        data: null,\n        id: id\n      }, '*');\n    } else if (type === 'run') {\n      benchmark.run(data.data.iterations);\n    }\n  }, false);\n\n  parent.postMessage({\n    type: 'init',\n    data: null,\n    id: id\n  }, '*');\n}\n\nfunction init(name, version, impl) {\n  // Parse Query String.\n  var qs = (function(a) {\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n      var p=a[i].split('=', 2);\n      if (p.length == 1) {\n        b[p[0]] = \"\";\n      } else {\n        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n      }\n    }\n    return b;\n  })(window.location.search.substr(1).split('&'));\n\n  if (qs['name'] !== void 0) {\n    name = qs['name'];\n  }\n\n  if (qs['version'] !== void 0) {\n    version = qs['version'];\n  }\n\n  var type = qs['type'];\n  var id;\n  if (type === 'iframe') {\n    id = qs['id'];\n    if (id === void 0) id = null;\n    initFromParentWindow(window.parent, name, version, id);\n  } else if (type === 'window') {\n    if (window.opener != null) {\n      id = qs['id'];\n      if (id === void 0) id = null;\n      initFromParentWindow(window.opener, name, version, id);\n    } else {\n      console.log('Failed to initialize: opener window is NULL');\n    }\n  } else {\n    var testsUrl = qs['data']; // url to the script generating test data\n    if (testsUrl !== void 0) {\n      initFromScript(testsUrl);\n    } else {\n      console.log('Failed to initialize: cannot load tests data');\n    }\n  }\n\n  benchmark.impl = impl;\n}\n\n// performance.now() polyfill\n// https://gist.github.com/paulirish/5438650\n// prepare base perf object\nif (typeof window.performance === 'undefined') {\n  window.performance = {};\n}\nif (!window.performance.now){\n  var nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n  window.performance.now = function now(){\n    return Date.now() - nowOffset;\n  };\n}\n\nmodule.exports = init;\n"]}